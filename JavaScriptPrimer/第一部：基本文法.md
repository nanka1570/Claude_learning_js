<!-- 2025_11_01 -->
# 第一部：基本文法
##　はじめに
### 疑問点
- 次の文が理解できなかった。
    > 「この書籍はGitHub上で公開されているため、GitHubリポジトリのIssueとしてあなたの疑問を報告できます。」

    GithubのIssueとは、バグが出たら情報を残し、担当者を割り振ることができる機能という認識。

## 1 JavaScriptとは
- JavaScriptは、ウェブブラウザだけでなく、サーバ側のアプリケーションを作る仕組みとしてNode.jsがが利用されている。
また、IoTでも動かせるものがある。

### JavaScriptとECMAScriptの違い
- ECMAScriptは共通な動作を定義している。そのため、どの実行環境でも基本的に同じ動作をする。
- 実行環境によって異なる部分もある。ブラウザではUIを操作するためのJavaScriptの機能が定義されていることに対し、Node.jsはサーバー側の処理を書くのでUIの操作に関する機能は不要。
- まとめとして、「ECMAScript」はどの実行環境でも共通の部分、「JavaScript」はECMAScriptと実行環境の固有機能も含んだ範囲。

### JavaScriptの特徴
1. オブジェクト同士のコミュニケーションで成り立っている
    - ECMAScriptの仕様として定められたオブジェクト、実行環境が定義したオブジェクト、ユーザーの定義したオブジェクトがコミュニケーションをとっている。
1. 大文字と小文字を区別する
    - 「name」と「NAME」は別の名前として認識するということ。
    - Javaの「String」のように、大文字で開始しなければならないという命名規則が意味を持つケースはない。
1. 予約語を持つ
    - 「const」などの予約語と同じ名前の変数名や関数名を宣言することはできない。
1. 文はセミコロンで区切られる
    - セミコロン（;）で文の終わりを表す。
    - スペース、タブ文字などの空白文字（ホワイトスペース）をプログラムに入れても挙動は変わらない。
1. strict mode
    - `use strict`とファイルまたは関数の先頭に書くことで、厳格なモードで実行することができる。
    - strict modeは`eval`や`with`といったレガシーな機能や構文を禁止し、あからかな問題を含んだコードには例外を投げる。
    = 以下のような状況では、`use strict`を宣言していれば例外が発生するが、宣言していなければグローバル変数が作られる。
    ```JS
    "use strict";
    mistypedVariable = 42; // => ReferenceError
    ```
1. 実行コンテキスト(ScriptとModule)
    - JavaScriptの実行コンテキストとして`Script`と`Module`がある。
    - `Script`は多くの実行環境でデフォルトの実行コンテキストとなっている。
    - `Script`はデフォルトでは`strict mode`ではないので、厳格モードにしたければ宣言する必要がある。
    - `Module`はデフォルトが`strict mode`なので、宣言しなくてもよい。
    - `Module`はモジュールの機能を使いたいときに使われる。
1. JavaScriptの仕様は毎年更新される
    - 新しい構文や機能が増え続けている。

--- 
<!-- 2025_11_02 -->
## 2 コメント

1. 一行コメント
    - `//`以降から行末までコメントとして扱われるため、プログラムとして評価されない。

    ```JS
    // 一行コメント
    // この部分はコードとして評価されない
    ```

1. 複数行コメント
    - `/*`と`*/`で囲まれた範囲がコメントとして扱われるため、プログラムとして評価されない。

    ```JS
    /*
   複数行コメント
   囲まれている範囲がコードとして評価されない
    */
    ```
    
    - 複数行コメントをネスとして書くと構文エラーになる。
    ```JS
    /* ネストされた /* 複数行コメント */ は書けない */
    ```
1. [ES2015] HTML-likeコメント
    - ECMAScript2015（ES2015）から後方互換性のための仕様としてHTML-likeコメントが実装された。
    - HTML-likeコメントは、HTMLと同じコメントの表記のこと。
    ```JS
    <!-- この行はコメントと認識される
    console.log("この行はJavaScriptのコードとして実行される");
    -->  この行もコメントと認識される
    ```
      - 昔JavaScriptをサポートしていないブラウザがあり、`<script>`タグを正しく認識できなかったため書かれたコードが表示されていた。その回避策として、表示はされないが実行されるという処置がされていた。
      - 今は、`<script>`タグをサポートしていないブラウザはないためこの回避策は不要だが、HTMLコメントが書かれているサイトは残っているため、後方互換性の仕様として追加されている。

## 3 変数と宣言

1. [ES2015] const
   - 再代入できない変数宣言。
    ```JS
    const bookTitle = "JavaScript Primer";
    ```

    - 再代入できないので、TypeErrorが発生する。
     ```JS
    const bookTitle = "JavaScript Primer";
    bookTitle = "新しいタイトル"; // => TypeError: invalid assignment to const 'bookTitle'
    ```

2. [ES2015] let
   - 再代入可能な変数宣言。
    ```JS
    let bookTitle = "JavaScript Primer";
    ```

    - 再代入できるので、エラーは発生しない。
    ```JS
    let bookTitle;
    bookTitle = "JavaScript Primer";
    ```
    何度でも値の代入が可能。
    ```JS
    let count = 0;
    count = 1;
    count = 2;
    count = 3;
    ```

    - `let`と違い、初期値を指定しない変数も定義できる。（指定しなければ`undefine`という値が入る）
    ```JS
    let bookTitle;
    // `bookTitle`は自動的に`undefined`という値になる
    ```

3. var
    - 再代入可能な変数。
    - ほぼ`let`と同じ使い方だが、同じ名前の変数を再定義できてしまう問題がある。
    ```JS
    // "x"という変数を定義する
    var x = 1;
    // 同じ名前の変数"x"を定義できる
    var x = 2;
    // 変数xは2となる
    ```
    - `var`は`const`や`let`に置き換え可能なので、できるだけ`var`は使わないほうが良い。

### `var`、`const`、`let`の業務使用率
- var：★☆☆☆☆
- const：★★★★☆
- let：★★★☆☆

### コラム 
#### なぜ`let`や`const`が追加されたか
- ECMAScript 2015では、`var`そのものを改善するのではなく、新しく`const`と`let`というキーワードを追加することで、`var`の問題を回避した。
  - `var`事態の動作を変更しなかったのは、後方互換性のため。
  - `var`の挙動を変えると、`var`で書かれたコードの動作が変わってしまうから。

#### 変数名に使える名前のルール
- 半角のアルファベット、_（アンダースコア）、$（ダラー）、数字を組み合わせた名前にする
- 変数名は数字から開始できない
- 予約語と被る名前は利用できない
    ```JS
    let $; // OK: $が利用できる
    let _title; // OK: _が利用できる
    let jquery; // OK: 小文字のアルファベットが利用できる
    let TITLE; // OK: 大文字のアルファベットが利用できる
    let es2015; // OK: 数字は先頭以外なら利用できる
    let 日本語の変数名; // OK: 一部の漢字や日本語も利用できる
    ```

#### `const`は定数ではない
  - `const`は「再代入できない変数」を定義する変数宣言であり、必ずしも定数を定義するわけではない。
    - `const`宣言を変更できないプリミティブな値で初期化すると、実質的に定数になる。
    ```JS
    // TEN_NUMBERという変数は常に10という値を示す
    const TEN_NUMBER = 10; 
    ```
    - しかし、JavaScriptではオブジェクトなども`const`宣言できるため、初期化した後でも変更できる。
    ```JS   
    // `const`でオブジェクトを定義している
    const object = {
        key: "値"
    };
    // オブジェクトそのものは変更できてしまう
    object.key = "新しい値";
    ```

### まとめ
1. `var`や`let`は、値を再代入可能だが、`const`は、値を再代入できない<span style="color:red">変数</span>である。
2. `var`は同じ名前の変数を定義できてしまうもんだいがあるため、あまり使わないほうが良い。
3. ECMAScriptでは、機能を追加する時も後方互換性を重視している。
   - 例：`var`の問題を解決するために`var`自体の変更をするのではなく、`const`や`let`を追加した。
4. `const`はプリミティブな値で初期化することで実質的に定数になるが、オブジェクトなどの初期化した後でも変更できるものの場合、定数とは呼べない。

## 4 値の評価と表示
### 開発者ツール
- ブラウザやNode.jsなど多くの実行環境には、コードを評価してその結果を表示するREPL(read-eval-print loop)と呼ばれる開発者向けの機能うがある。
- chromeにも「F12」開発者ツールのConsoleでREPL機能がある。
    入力１
    ```JS
    const bookTitle = "JavaScript Primer";
    ```
    結果
    ```JS
    undefined
    ```
    入力２
    ```JS
    bookTitle
    ```
    結果
    ```JS
    'JavaScript Primer'
    ```
### HTMLファイルを作成しJavaScriptコードを読み込む方法
- 多くの場合VSCodeなどのエディターを使用して作成する。
- しかし必ず文字コード（エンコーディング）はUTF-8、改行コードはLFにしてファイルを保存する。

### エラーの種類の一部と対処法
#### 構文エラー
JavaScriptでは、コードをパース（解釈）っしてから、プログラムを実行できる形に変換して実行する。
- そのため、コードをパースする際に文法の問題が見つかると、その時点で構文エラーが発生しプログラムとして実行できない。
1. `)`の書き忘れ
    ```JS
    console.log(1;
    ```
    結果
    ```JS
    Uncaught SyntaxError: missing ) after argument list (at 
    ```
    - エラーの種類はSyntaxErrorで、関数呼び出しの)が足りないこと
    
1. タイプミス
    ```JS
    cosnt a = 1;
    ```
    結果
    ```JS
    Uncaught SyntaxError: Unexpected identifier 'a' (at main.js:3:7)
    ```
  - エラーの種類はSyntaxErrorで、予期しない識別子（変数名 a）が指定されている

#### 実行時エラー
実行時（ランタイム）エラーとは、プログラムを実行している最中に発生するエラーのこと。
1. `ReferenceError`
    ```JS
    const value = "値";
    console.log(x);
    ``` 
    結果
    ```JS
    main.js:4 Uncaught ReferenceError: x is not defined
    ```
    - エラーの種類はReferenceErrorで、xという未定義の識別子を参照したため発生

### 疑問点
- エンコーディングとはなにか。
    →エンコーディング：文字を数値に変換するルール
- なぜ文字コードをUTF-8にし、改行コードをLFにしなければならないのか。  
>UTF-8を使う理由：
>1. 日本語を正しく扱える
>    - Shift_JISなど他の文字コードだと、環境によって文字化けする
>2. 世界標準
>    - ほぼすべてのブラウザやサーバーがUTF-8をサポート
>3. GitHubの推奨
>    - GitHubはUTF-8を推奨

>LF（改行コード）を使う理由：
>1. Unix/Linux/Macの標準
>   - Node.js、Git、サーバー環境はLFを想定
>2. Windowsの改行コード（CRLF）との違い
>   - Windows：CRLF（\r\n）
>   - Unix/Mac：LF（\n）
>3. チーム開発での統一
改行コードが混在すると、Gitで差分が出てしまう

---

<!-- 2025_11_03 -->
## 5 データ型とリテラル
  - JavaScriptは動的型付け言語に分類される言語のため、静的型付けのような**変数の型**はない。
  - しかし、文字列、数値、真偽値といった**値の型**は存在し、データ型と呼ぶ。
### データ型
  データ型を大きく分けると、**プリミティブ型**と**オブジェクト**の2つに分類される。
  - プリミティブ型（基本型）
    - 真偽値や数値などの基本的な値の型。
    - 一度作成したらその値自体を変更できない（イミュータブル）の特性を持つ。
    - 例）
      - 真偽値（Boolean）: trueまたはfalseのデータ型
      - 数値（Number）: 42 や 3.14159 などの数値のデータ型
      - 巨大な整数（BigInt）: ES2020から追加された9007199254740992nなどの任意精度の整数のデータ型
      - 文字列（String）: "JavaScript" などの文字列のデータ型
      - undefined: 値が未定義であることを意味するデータ型
      - null: 値が存在しないことを意味するデータ型
      - シンボル（Symbol）: ES2015から追加された一意で不変な値のデータ型
  - オブジェクト（複合型）
    - 複数のプリミティブ型の値またはオブジェクトからなる集合。
    - 一度作成した後でもその値自体を変更できる（ミュータブル）の特性を持つ。
    - 値そのものではなく値への参照を経由して操作されるため、参照型のデータとも言う。
    - 例）
      - プリミティブ型以外のデータ
      - オブジェクト、配列、関数、クラス、正規表現、Dateなど
#### `typeof`でデータ型を調べることができる
    ```JS
    console.log(typeof true);
    console.log(typeof 42);
    console.log(typeof 980071992540992n);
    console.log(typeof true);
    console.log(typeof "JavaScript"); 
    console.log(typeof Symbol("シンボル"));
    console.log(typeof undefined);
    console.log(typeof null);
    console.log(typeof ["配列"]);
    console.log(typeof { "key": "value" }); 
    console.log(typeof function() {});
    ```
    結果
    ```JS
    boolean main.js:18
    number main.js:19
    bigint main.js:20
    boolean main.js:21
    string main.js:22
    symbol main.js:23 
    undefined main.js:24 
    object main.js:25 
    object main.js:26
    object main.js:27
    function main.js:28 
    ```
- 配列`[]`とオブジェクト`{}`は、どちらも`object`という判定結果になる。そのため、`typeof`演算子ではオブジェクトの詳細な種類を正しく判定することはできない。
- 関数はオブジェクトの中でも特別扱いされているため、`typeof`演算子の評価結果は`function`になる。
### リテラル
#### 真偽値（Boolean）
    ```JS
    true; // => true
    false; // => false
    ```
#### 数値（Number）
- 数値には42のような整数リテラルと3.14159のような浮動小数点数リテラルがあります。
1. 整数リテラル
  10進数、2進数、8進数、16進数の4種類が扱われる。
   - 10進数
   0から9のみの数字で書かれた数値。
    ```JS
    console.log(1); // => 1
    console.log(10); // => 10
    console.log(255); // => 255
    ```
    - 2進数
        - `0b`から始まる。
        - ビットの表現によく利用される。
        - `b`は2進数を表すbinaryを意味している。     
    ```JS
    console.log(0b1111); // => 15
    console.log(0b10000000000); // => 1024
    ```
    - 8進数
        - `0o`から始まる。
        - ファイルのパーミッションを表現するのによく利用される。
        - `o`は8進数を表すoctalを意味している。
    ```JS
    console.log(0o644);  // => 420
    console.log(0o777);  // => 511
    ```
    - 16進数
        - `0x`から始まる。
        - 文字のコードポイントやRGB値の表現などに利用される。
        - `x`は16進数を表すhexを意味している。
    ```JS
    console.log(0xFF); // => 255
    // 小文字で書いても意味は同じ
    console.log(0xff); // => 255
    console.log(0x30A2); // => 12450
    ```
2. 浮動小数点数リテラル
    - 3.14159 のような .（ドット）を含んだ数値
    ```JS
    0.123; // => 0.123
    ```
    - 2e8 のような e または E を含んだ数値 
        - `e`は指数（exponent）を意味する記号で、`e`のあとに指数部の値を書く。
    ```JS
    2e8; // => 200000000
    ```
#### [ES2020] BigInt
JavaScriptでは、`1`や`3.14159`などの数値リテラルはIEEE754で定義された倍精度浮動小数となる。
- 倍精度浮動小数で正確に扱える数値の最大値は`2^53-1`（2の53乗から1を引いた値）`9007199254740991`。
- この数値リテラルで安全に表される最大の数値は`Number.Max_SAFE_INTEGER`として定義されている。
- 数値リテラルは倍精度浮動小数（64ビット）で数値を扱うのに対して、BigIntでは任意の制度の整数を扱える。

#### [ES2021] Numeric Separators
桁数の見間違いなどを起こさないように、ES2021から数値リテラル内の区切り文字として`_`が使えるようになった。
```JS
1_000_000_000_000;
```

#### 文字列（String）
以下すべて文字列として扱われる。
```JS
console.log("文字列"); // => "文字列"
console.log('文字列'); // => "文字列"
console.log(`文字列`); // => "文字列"
```
##### ダブルクォートとシングルクォート
- 文字列リテラル内に`'`などの文字列を表す記号を使いたい場合は、`\`でエスケープしなければならない。
```JS
"8 o'clock"; // => "8 o'clock"
```

- 文字列リテラル内で改行をしたい場合は、エスケープシーケンス`\n`を使わなければならない。
```JS
"複数行の\n文字列を\n入れたい";
```
##### [ES2015] テンプレートリテラル
- テンプレートリテラルは、`\``（バッククォート）で囲んだ範囲を文字列とするリテラル。
- C#で言う逐語的文字列リテラル`@`
```JS
`複数行の
文字列を
入れたい`; // => "複数行の\n文字列を\n入れたい"
```
- テンプレートリテラル内で`${変数名}`と書いた場合、その変数の値を埋め込むことができる。
```JS
const str = "文字列";
console.log(`これは${str}です`); // => "これは文字列です"
```
- テンプレートリテラルも他の文字列リテラルと同様に同じリテラル記号を内包したい場合は、\を使ってエスケープする必要があります。
```JS
`This is \`code\``;// => "This is `code`"
```
#### nullリテラル
- `null`は＾「値がない」ということを表現する値。

### オブジェクトリテラル
- `{}`（中かっこ）を書くことで、新しいオブジェクトを作成できる。

- オブジェクトのキーと値を`:`で区切ると作成と初期化ができる。
- キー名には文字列またはSymbolを指定し、値にはプリミティブ型の値からオブジェクトまでなんでも入れることができる。
```JS
const obj = {
    "key": "value"
};
```
- このとき、オブジェクトが持つキーのことをプロパティ名と呼ぶ。
##### オブジェクトのプロパティを参照する方法
`.`でつないで参照する方法と、`[]`（ブラケット）で参照する方法がある。
```JS
const obj = {
    "key": "value"
};
// ドット記法
console.log(obj.key); // => "value"
// ブラケット記法
console.log(obj["key"]); // => "value"
```
- ドット記法は、プロパティ名が変数名と同じく識別子である必要があるため、次のように識別子として利用できないプロパティ名はドット記法として書けない。
```JS
// プロパティ名は文字列の"123"
const object = {
    "123": "value"
};
// OK: ブラケット記法では、文字列として書くことができる
console.log(object["123"]); // => "value"
// NG: ドット記法では、数値からはじまる識別子は利用できない
object.123
```

### 配列リテラル
- `[`と`]`で値をカンマで区切り囲み、その値を持つArrayオブジェクトを作成する。
```JS
const emptyArray = []; // 空の配列を作成
const array = [1, 2, 3]; // 値を持った配列を作成
```
- 配列の要素を取得するには、`array[index]`という構文で指定したインデックスの値を参照する。

### 正規表現リテラル
- JavaScriptでは、正規表現をリテラルで書くことができる。
- `/`（スラッシュ）と`/`（スラッシュ）で正規表現のパターン文字列を囲む。
    - 以下の例では、数字にマッチする特殊文字である`\d`を使い、1文字以上の数字にマッチする正規表現をリテラルで表現しています。
```JS
const numberRegExp = /\d+/; // 1文字以上の数字にマッチする正規表現
// `numberRegExp`の正規表現が文字列"123"にマッチするかをテストする
console.log(numberRegExp.test("123")); // => true
```

### プリミティブ型とオブジェクト
- プリミティブ型は基本的にリテラルで表現するが、真偽値（Boolean）、数値（Number）、文字列（String）はそれぞれオブジェクトとして表現する方法もある。**（ラッパーオブジェクト）**
- ラッパーオブジェクトは、`new`演算しと対応するコンストラクタ関数を利用して作成できる。
- 例）
```JS
// 文字列をラップしたStringラッパーオブジェクト
const str = new String("文字列");
// ラッパーオブジェクトは"object"型のデータ
console.log(typeof str); // => "object"
// Stringオブジェクトの`length`プロパティは文字列の長さを返す
console.log(str.length); // => 3
```
- しかし明示的にラッパーオブジェクトを使うべきではなく、JavaScriptではプリミティブ型の文字列データに対しても`length`プロパティへアクセスできている。
```JS
// プリミティブ型の文字列データ
const str = "文字列";
// プリミティブ型の文字列は"string"型のデータ
console.log(typeof str); // => "string"
// プリミティブ型の文字列も`length`プロパティを参照できる
console.log(str.length); // => 3
```
- プリミティブ型のデータのプロパティへアクセスする際に、対応するラッパーオブジェクトへ暗黙的に変換してからプロパティへアクセスするから、明示的にかかなくてもラッパーオブジェクトととして扱える。

### コラム
#### undefinedはリテラルではない
- `undefined`はただのグローバル変数で、`undefined`という値を持っているだけ。
### 疑問点
#### 数値
- ファイルのパーミッションとは。
- markdownで`を``で囲む方法。
    `を\でエスケープしてみても駄目だった。
#### オブジェクトリテラル
- 識別子とは、文字列の値という認識で会っているか。
  <span style="color:red">識別子（Identifier）は、変数名、関数名、プロパティ名など、プログラム内で何かを識別するための名前のこと。</span>
#### 正規表現リテラル
- 正規表現をリテラルで書かない方法もある？
`````javascript
// リテラルで書く方法
const regex1 = /\d+/;

// コンストラクタで書く方法
const regex2 = new RegExp("\\d+");

// どちらも同じ意味
console.log(regex1.test("123"));  // true
console.log(regex2.test("123"));  // true
`````
- 正規表現の変数を定義したらboolean型になる？
  <span style="color:red">正規表現はobject形で、test()メソッドの返り値がboolean</span>

`````javascript
const regex = /\d+/;
console.log(typeof regex);  // "object"

// test()メソッドの返り値がboolean
console.log(regex.test("123"));  // true（boolean型）
console.log(typeof regex.test("123"));  // "boolean"
`````

**説明**：
- 正規表現自体は**RegExpオブジェクト**（object型）
- `test()`メソッドの**返り値**がboolean型
- 
---

<!-- 2025_11_04 -->
## 6 演算子
演算子には二項演算子と単項演算子がある。

### 二項演算子
#### プラス演算子（`+`）
2つの数値を加算する演算子。
```JS
console.log(1 + 1); // => 2
```

#### 文字列結合演算子（`+`）
2つの文字列を結合する演算子。
```JS
const value = "文字列" + "結合";
console.log(value); // => "文字列結合"
```

#### マイナス演算子（`-`）
2つの数値を減算する演算子。
```JS
console.log(1 - 1); // => 0
console.log(10 - 0.5); // => 9.5
```

#### 乗算演算子（`*`）
2つの数値を乗算する演算子。
```JS
console.log(2 * 8); // => 16
console.log(10 * 0.5); // => 5
```

#### 除算演算子（`/`）
2つの数値を除算する演算子。
```JS
console.log(8 / 2); // => 4
console.log(10 / 0.5); // => 20
```

#### 剰余演算子（`%`）
```JS
console.log(8 % 2); // => 0
console.log(9 % 2); // => 1
console.log(10 % 0.5); // => 0
console.log(10 % 4.5); // => 1
```

#### [ES2016] べき乗演算子（`**`）
2つの数値のべき乗を求める演算子。
```JS
// べき乗演算子（ES2016）で2の4乗を計算
console.log(2 ** 4); // => 16
```
同じ動きをする`Math.pow`静的メソッドがある。
```JS
console.log(Math.pow(2, 4)); // => 16
```

### 単項演算子（算術）
1つのオペランドを受け取り処理する演算子。

#### 単項プラス演算子（`+`）
単項演算子の`+`はオペランドを数値に変換する。
```JS
console.log(+"1"); // => 1
```
- 以下のように文字列は数値に変換できず、`Nan`となる。
```JS
console.log(+"1"); // => 1
```
- `NaN`はNot-a-Numberの略称で、数値ではないがNumber型の値を表現している。
- `NaN`はどの値とも（NaN自身に対しても）一致しない特性があり、`Number.isNaN`静的メソッドを使うことで`NaN`の判定を行える。
```JS
// 自分自身とも一致しない
console.log(NaN === NaN); // => false
// Number型である
console.log(typeof NaN); // => "number"
// Number.isNaNでNaNかどうかを判定
console.log(Number.isNaN(NaN)); // => true
```
- しかし、文字列から数値の返還に単項プラス演算子を使うべきではない。
`Number`コンストラクタ関数や`ParseInt`関数などの明示的な返還方法が存在するため。

#### 単項マイナス演算子（`-`）
- 単項マイナス演算子はマイナスの数値を反転できる。
```JS
console.log(-(-1)); // => 1
```
- 単項マイナス演算子も文字列などを数値へ変換できる。
```JS
console.log(-"1"); // => -1
```

#### インクリメント演算子（`++`）
オペランドの数値を`+1`する演算子。

#### デクリメント演算子（`--`）
オペランドの数値を`-1`する演算子。

### 比較演算子
オペランド同士の値を比較し、真偽値を返す演算子。

#### 厳密等価演算子（`===`）
同じ型で同じ値の時に`true`を返す。

#### 厳密不等価演算子（`!==`）
異なる方または異なる値である場合に`true`を返す。

#### 等価演算子（`==`）
同じデータ型のオペランドを比較する場合は、厳密等価演算子と同じ結果になるが、異なる型の場合**暗黙的な型変換**をしてから比較する。

#### 不等価演算子（`!=`）
等価演算子同様、暗黙的な型変換をしてから比較する。

#### 大なり演算子/より大きい（`>`）
左オペランドが右オペランドより大きい場合、`true`を返す。

#### 大なりいオール演算子/以上（`>=`）
左オペランドが右オペランドより大きいまたは等しいならば、`true`を返す。

#### 小なり演算子/より小さい（`<`）
左オペランドが右オペランドより小さいならば、`true`を返す。

#### 小なりイコール演算子/以下（`<=`）
小なり演算子または等しいならば`true`を返す。

### ビット演算子（ToDo）

### [ES2015] 分割代入（Destructuring assignment）
配列やオブジェクトを分割して一つの変数にできるもの。

### 論理演算子
基本的に真偽値を扱う演算子。

#### AND演算子（`&&`）
左辺の値が`true`なら、右辺の評価結果を返す。
`false`の場合は、右辺が実行されない。
    →**短絡評価**

#### OR演算子（`||`）
左辺の値の評価結果が`true`ならば、そのまま左辺を返し、`false`だったら、右辺の評価結果を返す。

#### NOT演算子（`!`）
オペランドの評価が`true`ならば`false`を返し、`false`ならば`true`を返す。

### [ES2020] Nullish coalescing演算子(??)
左辺の値が**nullish**であるならば、右辺の評価結果を返します。
nullish → 評価結果が`null`または`undefined`となる値のこと。

#### 卒業制作
予約フォームに入力した値のチェックをするために、以下のように使った記憶がある。
```js
const user_name = "入力値" ?? "名前がありません。";
```

### 条件（三項）演算子（`?`と`:`）（ToDo：よくわからなかった）
```js
条件式?Trueの時処理する式：Falseの時処理する式；
```

### グループ化演算子（`(`と`)`）
`()`の中の計算を先に行うという演算子。

### カンマ演算子（`,`）
区切った式を左から順に評価し、最後の式の評価結果を返す。
```js
const a = 1, b = 2, c = a + b;
console.log(c); // => 3
```

### まとめ
- 演算子は、計算や値を評価する時に使われるもの
- 数学で使われる四則演算や、プログラミング特有の論理演算があり、JavaScript特有の厳密等価演算子、厳密不等価演算子がある。

## 7 暗黙的な型変換
### さまざまな暗黙的な型変換
暗黙的な型変換は結果の予想が難しい。
- 2つの値までなら結果の様相がまだできる
- 以下のように3つになると予測が難しくなる
    - おそらく左オペランドから演算されるから上２つは文字列結合、一番下は最初だけ数値計算して文字列結合をしていると予想。
```js
const x = 1, y = "2", z = 3;
console.log(x + y + z); // => "123"
console.log(y + x + z); // => "213"
console.log(x + z + y); // => "42"
```
### 明示的な型変換
プリミティブ型へ明示的な型変換をする方法

#### 任意の値から真偽値
- 以下のfalsyな値は`false`に変換される
  - `false`
  - `undefined`
  - `null`
  - `0`
  - `0n`
  - `NaN`
  - `""`
- falsyな値以外は`true`に変換される

#### 数値から文字列
Stringコンストラクタ関数で、数値以外にもいろいろな値を文字列へと変換できる
しかし、配列にっは`join`メソッド、オブジェクトには`JSON.stringify`静的メソッドなどの方法があるため、プリミティブ型に対してのみとどめるべき
```js
String("str"); // => "str"
String(true); // => "true"
String(null); // => "null"
String(undefined); // => "undefined"
String(Symbol("シンボルの説明文")); // => "Symbol(シンボルの説明文)"
// プリミティブ型ではない値の場合
String([1, 2, 3]); // => "1,2,3"
String({ key: "value" }); // => "[object Object]"
String(function() {}); // "function() {}"
```

#### シンボルから文字列
ES2015で追加されたプリミティブ型であるシンボルは暗黙的に変換できないが、
```js
"文字列と" + Symbol("シンボルの説明"); // => TypeError: can't convert symbol to string
```
以下のようにStringコンストラクタ関数を使うことでシンボルを明示的に文字列化することができます。

#### 文字列から数値
- 文字列から数値に変換するにはNumberコンストラクタ関数を使う。
```js
// ユーザー入力を文字列として受け取る
const input = window.prompt("数字を入力してください", "42");
// 文字列を数値に変換する
const num = Number(input);
console.log(typeof num); // => "number"
console.log(num); // 入力された文字列を数値に変換したもの
```

- 文字列から数字を取り出して変換する関数（`Number.parseInt`、`Number.parseFloat`）も使える。
```js
// "1"をパースして10進数として取り出す
console.log(Number.parseInt("1", 10)); // => 1
// 余計な文字は無視してパースした結果を返す
console.log(Number.parseInt("42px", 10)); // => 42
console.log(Number.parseInt("10.5", 10)); // => 10
// 文字列をパースして浮動小数点数として取り出す
console.log(Number.parseFloat("1")); // => 1
console.log(Number.parseFloat("42.5px")); // => 42.5
console.log(Number.parseFloat("10.5")); // => 10.5
```

#### NanはNot a NumberだけどNumber型

- NaNは自分自身と一致しない
```js
function isNaN(x) {
    // NaNは自分自身と一致しない
    return x !== x;
}
console.log(isNaN(1)); // => false
console.log(isNaN("str")); // => false
console.log(isNaN({})); // => false
console.log(isNaN([])); // => false
console.log(isNaN(NaN)); // => true
```

#### 疑問点
- Symbolとは何か？
  - 一意性：同じ説明文でも別のSymbolは異なる値
  - 不変：作成後、値を変更できない
  - 列挙されない：`for...in`などで列挙されない

## 8 関数と宣言

### ２種類の関数がある
- functionキーワード`function 関数名(仮引数1,仮引数2){}`
```js
// 関数宣言
function 関数名(仮引数1, 仮引数2) {
    // 関数が呼び出されたときの処理
    // ...
    return 関数の返り値;
}
// 関数呼び出し
const 関数の結果 = 関数名(引数1, 引数2);
console.log(関数の結果); // => 関数の返り値
```

- アロー関数

### [ES2015]デフォルト引数
以下のように関数の仮引数にデフォルト値を渡すことができる。
```js
function echo(x = "デフォルト値") {
    return x;
}

console.log(echo(1)); // => 1
console.log(echo()); // => "デフォルト値"
```

#### 疑問
- 仮引数にデフォルト値を渡すのは初期値の代入みたいなものの認識。
