<!-- 2025_11_01 -->
# 第一部：基本文法
##　はじめに
### 疑問点
- 次の文が理解できなかった。
    > 「この書籍はGitHub上で公開されているため、GitHubリポジトリのIssueとしてあなたの疑問を報告できます。」

    GithubのIssueとは、バグが出たら情報を残し、担当者を割り振ることができる機能という認識。

## 1 JavaScriptとは
- JavaScriptは、ウェブブラウザだけでなく、サーバ側のアプリケーションを作る仕組みとしてNode.jsがが利用されている。
また、IoTでも動かせるものがある。

### JavaScriptとECMAScriptの違い
- ECMAScriptは共通な動作を定義している。そのため、どの実行環境でも基本的に同じ動作をする。
- 実行環境によって異なる部分もある。ブラウザではUIを操作するためのJavaScriptの機能が定義されていることに対し、Node.jsはサーバー側の処理を書くのでUIの操作に関する機能は不要。
- まとめとして、「ECMAScript」はどの実行環境でも共通の部分、「JavaScript」はECMAScriptと実行環境の固有機能も含んだ範囲。

### JavaScriptの特徴
1. オブジェクト同士のコミュニケーションで成り立っている
    - ECMAScriptの仕様として定められたオブジェクト、実行環境が定義したオブジェクト、ユーザーの定義したオブジェクトがコミュニケーションをとっている。
1. 大文字と小文字を区別する
    - 「name」と「NAME」は別の名前として認識するということ。
    - Javaの「String」のように、大文字で開始しなければならないという命名規則が意味を持つケースはない。
1. 予約語を持つ
    - 「const」などの予約語と同じ名前の変数名や関数名を宣言することはできない。
1. 文はセミコロンで区切られる
    - セミコロン（;）で文の終わりを表す。
    - スペース、タブ文字などの空白文字（ホワイトスペース）をプログラムに入れても挙動は変わらない。
1. strict mode
    - `use strict`とファイルまたは関数の先頭に書くことで、厳格なモードで実行することができる。
    - strict modeは`eval`や`with`といったレガシーな機能や構文を禁止し、あからかな問題を含んだコードには例外を投げる。
    = 以下のような状況では、`use strict`を宣言していれば例外が発生するが、宣言していなければグローバル変数が作られる。
    ```JS
    "use strict";
    mistypedVariable = 42; // => ReferenceError
    ```
1. 実行コンテキスト(ScriptとModule)
    - JavaScriptの実行コンテキストとして`Script`と`Module`がある。
    - `Script`は多くの実行環境でデフォルトの実行コンテキストとなっている。
    - `Script`はデフォルトでは`strict mode`ではないので、厳格モードにしたければ宣言する必要がある。
    - `Module`はデフォルトが`strict mode`なので、宣言しなくてもよい。
    - `Module`はモジュールの機能を使いたいときに使われる。
1. JavaScriptの仕様は毎年更新される
    - 新しい構文や機能が増え続けている。

--- 
<!-- 2025_11_02 -->
## 2 コメント

1. 一行コメント
    - `//`以降から行末までコメントとして扱われるため、プログラムとして評価されない。

    ```JS
    // 一行コメント
    // この部分はコードとして評価されない
    ```

1. 複数行コメント
    - `/*`と`*/`で囲まれた範囲がコメントとして扱われるため、プログラムとして評価されない。

    ```JS
    /*
   複数行コメント
   囲まれている範囲がコードとして評価されない
    */
    ```
    
    - 複数行コメントをネスとして書くと構文エラーになる。
    ```JS
    /* ネストされた /* 複数行コメント */ は書けない */
    ```
1. [ES2015] HTML-likeコメント
    - ECMAScript2015（ES2015）から後方互換性のための仕様としてHTML-likeコメントが実装された。
    - HTML-likeコメントは、HTMLと同じコメントの表記のこと。
    ```JS
    <!-- この行はコメントと認識される
    console.log("この行はJavaScriptのコードとして実行される");
    -->  この行もコメントと認識される
    ```
      - 昔JavaScriptをサポートしていないブラウザがあり、`<script>`タグを正しく認識できなかったため書かれたコードが表示されていた。その回避策として、表示はされないが実行されるという処置がされていた。
      - 今は、`<script>`タグをサポートしていないブラウザはないためこの回避策は不要だが、HTMLコメントが書かれているサイトは残っているため、後方互換性の仕様として追加されている。

## 3 変数と宣言

1. [ES2015] const
   - 再代入できない変数宣言。
    ```JS
    const bookTitle = "JavaScript Primer";
    ```

    - 再代入できないので、TypeErrorが発生する。
     ```JS
    const bookTitle = "JavaScript Primer";
    bookTitle = "新しいタイトル"; // => TypeError: invalid assignment to const 'bookTitle'
    ```

2. [ES2015] let
   - 再代入可能な変数宣言。
    ```JS
    let bookTitle = "JavaScript Primer";
    ```

    - 再代入できるので、エラーは発生しない。
    ```JS
    let bookTitle;
    bookTitle = "JavaScript Primer";
    ```
    何度でも値の代入が可能。
    ```JS
    let count = 0;
    count = 1;
    count = 2;
    count = 3;
    ```

    - `let`と違い、初期値を指定しない変数も定義できる。（指定しなければ`undefine`という値が入る）
    ```JS
    let bookTitle;
    // `bookTitle`は自動的に`undefined`という値になる
    ```

3. var
    - 再代入可能な変数。
    - ほぼ`let`と同じ使い方だが、同じ名前の変数を再定義できてしまう問題がある。
    ```JS
    // "x"という変数を定義する
    var x = 1;
    // 同じ名前の変数"x"を定義できる
    var x = 2;
    // 変数xは2となる
    ```
    - `var`は`const`や`let`に置き換え可能なので、できるだけ`var`は使わないほうが良い。

### `var`、`const`、`let`の業務使用率
- var：★☆☆☆☆
- const：★★★★☆
- let：★★★☆☆

### コラム 
#### なぜ`let`や`const`が追加されたか
- ECMAScript 2015では、`var`そのものを改善するのではなく、新しく`const`と`let`というキーワードを追加することで、`var`の問題を回避した。
  - `var`事態の動作を変更しなかったのは、後方互換性のため。
  - `var`の挙動を変えると、`var`で書かれたコードの動作が変わってしまうから。

#### 変数名に使える名前のルール
- 半角のアルファベット、_（アンダースコア）、$（ダラー）、数字を組み合わせた名前にする
- 変数名は数字から開始できない
- 予約語と被る名前は利用できない
    ```JS
    let $; // OK: $が利用できる
    let _title; // OK: _が利用できる
    let jquery; // OK: 小文字のアルファベットが利用できる
    let TITLE; // OK: 大文字のアルファベットが利用できる
    let es2015; // OK: 数字は先頭以外なら利用できる
    let 日本語の変数名; // OK: 一部の漢字や日本語も利用できる
    ```

#### `const`は定数ではない
  - `const`は「再代入できない変数」を定義する変数宣言であり、必ずしも定数を定義するわけではない。
    - `const`宣言を変更できないプリミティブな値で初期化すると、実質的に定数になる。
    ```JS
    // TEN_NUMBERという変数は常に10という値を示す
    const TEN_NUMBER = 10; 
    ```
    - しかし、JavaScriptではオブジェクトなども`const`宣言できるため、初期化した後でも変更できる。
    ```JS   
    // `const`でオブジェクトを定義している
    const object = {
        key: "値"
    };
    // オブジェクトそのものは変更できてしまう
    object.key = "新しい値";
    ```

### まとめ
1. `var`や`let`は、値を再代入可能だが、`const`は、値を再代入できない<span style="color:red">変数</span>である。
2. `var`は同じ名前の変数を定義できてしまうもんだいがあるため、あまり使わないほうが良い。
3. ECMAScriptでは、機能を追加する時も後方互換性を重視している。
   - 例：`var`の問題を解決するために`var`自体の変更をするのではなく、`const`や`let`を追加した。
4. `const`はプリミティブな値で初期化することで実質的に定数になるが、オブジェクトなどの初期化した後でも変更できるものの場合、定数とは呼べない。

## 4 値の評価と表示
### 開発者ツール
- ブラウザやNode.jsなど多くの実行環境には、コードを評価してその結果を表示するREPL(read-eval-print loop)と呼ばれる開発者向けの機能うがある。
- chromeにも「F12」開発者ツールのConsoleでREPL機能がある。
    入力１
    ```JS
    const bookTitle = "JavaScript Primer";
    ```
    結果
    ```JS
    undefined
    ```
    入力２
    ```JS
    bookTitle
    ```
    結果
    ```JS
    'JavaScript Primer'
    ```
### HTMLファイルを作成しJavaScriptコードを読み込む方法
- 多くの場合VSCodeなどのエディターを使用して作成する。
- しかし必ず文字コード（エンコーディング）はUTF-8、改行コードはLFにしてファイルを保存する。

### エラーの種類の一部と対処法
#### 構文エラー
JavaScriptでは、コードをパース（解釈）っしてから、プログラムを実行できる形に変換して実行する。
- そのため、コードをパースする際に文法の問題が見つかると、その時点で構文エラーが発生しプログラムとして実行できない。
1. `)`の書き忘れ
    ```JS
    console.log(1;
    ```
    結果
    ```JS
    Uncaught SyntaxError: missing ) after argument list (at 
    ```
    - エラーの種類はSyntaxErrorで、関数呼び出しの)が足りないこと
    
1. タイプミス
    ```JS
    cosnt a = 1;
    ```
    結果
    ```JS
    Uncaught SyntaxError: Unexpected identifier 'a' (at main.js:3:7)
    ```
  - エラーの種類はSyntaxErrorで、予期しない識別子（変数名 a）が指定されている

#### 実行時エラー
実行時（ランタイム）エラーとは、プログラムを実行している最中に発生するエラーのこと。
1. `ReferenceError`
    ```JS
    const value = "値";
    console.log(x);
    ``` 
    結果
    ```JS
    main.js:4 Uncaught ReferenceError: x is not defined
    ```
    - エラーの種類はReferenceErrorで、xという未定義の識別子を参照したため発生

### 疑問点
- エンコーディングとはなにか。
    →エンコーディング：文字を数値に変換するルール
- なぜ文字コードをUTF-8にし、改行コードをLFにしなければならないのか。  
>UTF-8を使う理由：
>1. 日本語を正しく扱える
>    - Shift_JISなど他の文字コードだと、環境によって文字化けする
>2. 世界標準
>    - ほぼすべてのブラウザやサーバーがUTF-8をサポート
>3. GitHubの推奨
>    - GitHubはUTF-8を推奨

>LF（改行コード）を使う理由：
>1. Unix/Linux/Macの標準
>   - Node.js、Git、サーバー環境はLFを想定
>2. Windowsの改行コード（CRLF）との違い
>   - Windows：CRLF（\r\n）
>   - Unix/Mac：LF（\n）
>3. チーム開発での統一
改行コードが混在すると、Gitで差分が出てしまう

---

<!-- 2025_11_03 -->
## 5 データ型とリテラル
  - JavaScriptは動的型付け言語に分類される言語のため、静的型付けのような**変数の型**はない。
  - しかし、文字列、数値、真偽値といった**値の型**は存在し、データ型と呼ぶ。
### データ型
  データ型を大きく分けると、**プリミティブ型**と**オブジェクト**の2つに分類される。
  - プリミティブ型（基本型）
    - 真偽値や数値などの基本的な値の型。
    - 一度作成したらその値自体を変更できない（イミュータブル）の特性を持つ。
    - 例）
      - 真偽値（Boolean）: trueまたはfalseのデータ型
      - 数値（Number）: 42 や 3.14159 などの数値のデータ型
      - 巨大な整数（BigInt）: ES2020から追加された9007199254740992nなどの任意精度の整数のデータ型
      - 文字列（String）: "JavaScript" などの文字列のデータ型
      - undefined: 値が未定義であることを意味するデータ型
      - null: 値が存在しないことを意味するデータ型
      - シンボル（Symbol）: ES2015から追加された一意で不変な値のデータ型
  - オブジェクト（複合型）
    - 複数のプリミティブ型の値またはオブジェクトからなる集合。
    - 一度作成した後でもその値自体を変更できる（ミュータブル）の特性を持つ。
    - 値そのものではなく値への参照を経由して操作されるため、参照型のデータとも言う。
    - 例）
      - プリミティブ型以外のデータ
      - オブジェクト、配列、関数、クラス、正規表現、Dateなど
#### `typeof`でデータ型を調べることができる
    ```JS
    console.log(typeof true);
    console.log(typeof 42);
    console.log(typeof 980071992540992n);
    console.log(typeof true);
    console.log(typeof "JavaScript"); 
    console.log(typeof Symbol("シンボル"));
    console.log(typeof undefined);
    console.log(typeof null);
    console.log(typeof ["配列"]);
    console.log(typeof { "key": "value" }); 
    console.log(typeof function() {});
    ```
    結果
    ```JS
    boolean main.js:18
    number main.js:19
    bigint main.js:20
    boolean main.js:21
    string main.js:22
    symbol main.js:23 
    undefined main.js:24 
    object main.js:25 
    object main.js:26
    object main.js:27
    function main.js:28 
    ```
- 配列`[]`とオブジェクト`{}`は、どちらも`object`という判定結果になる。そのため、`typeof`演算子ではオブジェクトの詳細な種類を正しく判定することはできない。
- 関数はオブジェクトの中でも特別扱いされているため、`typeof`演算子の評価結果は`function`になる。
### リテラル
#### 真偽値（Boolean）
    ```JS
    true; // => true
    false; // => false
    ```
#### 数値（Number）
- 数値には42のような整数リテラルと3.14159のような浮動小数点数リテラルがあります。
1. 整数リテラル
  10進数、2進数、8進数、16進数の4種類が扱われる。
   - 10進数
   0から9のみの数字で書かれた数値。
    ```JS
    console.log(1); // => 1
    console.log(10); // => 10
    console.log(255); // => 255
    ```
    - 2進数
        - `0b`から始まる。
        - ビットの表現によく利用される。
        - `b`は2進数を表すbinaryを意味している。     
    ```JS
    console.log(0b1111); // => 15
    console.log(0b10000000000); // => 1024
    ```
    - 8進数
        - `0o`から始まる。
        - ファイルのパーミッションを表現するのによく利用される。
        - `o`は8進数を表すoctalを意味している。
    ```JS
    console.log(0o644);  // => 420
    console.log(0o777);  // => 511
    ```
    - 16進数
        - `0x`から始まる。
        - 文字のコードポイントやRGB値の表現などに利用される。
        - `x`は16進数を表すhexを意味している。
    ```JS
    console.log(0xFF); // => 255
    // 小文字で書いても意味は同じ
    console.log(0xff); // => 255
    console.log(0x30A2); // => 12450
    ```
2. 浮動小数点数リテラル
    - 3.14159 のような .（ドット）を含んだ数値
    ```JS
    0.123; // => 0.123
    ```
    - 2e8 のような e または E を含んだ数値 
        - `e`は指数（exponent）を意味する記号で、`e`のあとに指数部の値を書く。
    ```JS
    2e8; // => 200000000
    ```
#### [ES2020] BigInt
JavaScriptでは、`1`や`3.14159`などの数値リテラルはIEEE754で定義された倍精度浮動小数となる。
- 倍精度浮動小数で正確に扱える数値の最大値は`2^53-1`（2の53乗から1を引いた値）`9007199254740991`。
- この数値リテラルで安全に表される最大の数値は`Number.Max_SAFE_INTEGER`として定義されている。
- 数値リテラルは倍精度浮動小数（64ビット）で数値を扱うのに対して、BigIntでは任意の制度の整数を扱える。

#### [ES2021] Numeric Separators
桁数の見間違いなどを起こさないように、ES2021から数値リテラル内の区切り文字として`_`が使えるようになった。
```JS
1_000_000_000_000;
```

#### 文字列（String）
以下すべて文字列として扱われる。
```JS
console.log("文字列"); // => "文字列"
console.log('文字列'); // => "文字列"
console.log(`文字列`); // => "文字列"
```
##### ダブルクォートとシングルクォート
- 文字列リテラル内に`'`などの文字列を表す記号を使いたい場合は、`\`でエスケープしなければならない。
```JS
"8 o'clock"; // => "8 o'clock"
```

- 文字列リテラル内で改行をしたい場合は、エスケープシーケンス`\n`を使わなければならない。
```JS
"複数行の\n文字列を\n入れたい";
```
##### [ES2015] テンプレートリテラル
- テンプレートリテラルは、`\``（バッククォート）で囲んだ範囲を文字列とするリテラル。
- C#で言う逐語的文字列リテラル`@`
```JS
`複数行の
文字列を
入れたい`; // => "複数行の\n文字列を\n入れたい"
```
- テンプレートリテラル内で`${変数名}`と書いた場合、その変数の値を埋め込むことができる。
```JS
const str = "文字列";
console.log(`これは${str}です`); // => "これは文字列です"
```
- テンプレートリテラルも他の文字列リテラルと同様に同じリテラル記号を内包したい場合は、\を使ってエスケープする必要があります。
```JS
`This is \`code\``;// => "This is `code`"
```
#### nullリテラル
- `null`は＾「値がない」ということを表現する値。

### オブジェクトリテラル
- `{}`（中かっこ）を書くことで、新しいオブジェクトを作成できる。

- オブジェクトのキーと値を`:`で区切ると作成と初期化ができる。
- キー名には文字列またはSymbolを指定し、値にはプリミティブ型の値からオブジェクトまでなんでも入れることができる。
```JS
const obj = {
    "key": "value"
};
```
- このとき、オブジェクトが持つキーのことをプロパティ名と呼ぶ。
##### オブジェクトのプロパティを参照する方法
`.`でつないで参照する方法と、`[]`（ブラケット）で参照する方法がある。
```JS
const obj = {
    "key": "value"
};
// ドット記法
console.log(obj.key); // => "value"
// ブラケット記法
console.log(obj["key"]); // => "value"
```
- ドット記法は、プロパティ名が変数名と同じく識別子である必要があるため、次のように識別子として利用できないプロパティ名はドット記法として書けない。
```JS
// プロパティ名は文字列の"123"
const object = {
    "123": "value"
};
// OK: ブラケット記法では、文字列として書くことができる
console.log(object["123"]); // => "value"
// NG: ドット記法では、数値からはじまる識別子は利用できない
object.123
```

### 配列リテラル
- `[`と`]`で値をカンマで区切り囲み、その値を持つArrayオブジェクトを作成する。
```JS
const emptyArray = []; // 空の配列を作成
const array = [1, 2, 3]; // 値を持った配列を作成
```
- 配列の要素を取得するには、`array[index]`という構文で指定したインデックスの値を参照する。

### 正規表現リテラル
- JavaScriptでは、正規表現をリテラルで書くことができる。
- `/`（スラッシュ）と`/`（スラッシュ）で正規表現のパターン文字列を囲む。
    - 以下の例では、数字にマッチする特殊文字である`\d`を使い、1文字以上の数字にマッチする正規表現をリテラルで表現しています。
```JS
const numberRegExp = /\d+/; // 1文字以上の数字にマッチする正規表現
// `numberRegExp`の正規表現が文字列"123"にマッチするかをテストする
console.log(numberRegExp.test("123")); // => true
```

### プリミティブ型とオブジェクト
- プリミティブ型は基本的にリテラルで表現するが、真偽値（Boolean）、数値（Number）、文字列（String）はそれぞれオブジェクトとして表現する方法もある。**（ラッパーオブジェクト）**
- ラッパーオブジェクトは、`new`演算しと対応するコンストラクタ関数を利用して作成できる。
- 例）
```JS
// 文字列をラップしたStringラッパーオブジェクト
const str = new String("文字列");
// ラッパーオブジェクトは"object"型のデータ
console.log(typeof str); // => "object"
// Stringオブジェクトの`length`プロパティは文字列の長さを返す
console.log(str.length); // => 3
```
- しかし明示的にラッパーオブジェクトを使うべきではなく、JavaScriptではプリミティブ型の文字列データに対しても`length`プロパティへアクセスできている。
```JS
// プリミティブ型の文字列データ
const str = "文字列";
// プリミティブ型の文字列は"string"型のデータ
console.log(typeof str); // => "string"
// プリミティブ型の文字列も`length`プロパティを参照できる
console.log(str.length); // => 3
```
- プリミティブ型のデータのプロパティへアクセスする際に、対応するラッパーオブジェクトへ暗黙的に変換してからプロパティへアクセスするから、明示的にかかなくてもラッパーオブジェクトととして扱える。

### コラム
#### undefinedはリテラルではない
- `undefined`はただのグローバル変数で、`undefined`という値を持っているだけ。
### 疑問点
#### 数値
- ファイルのパーミッションとは。
- markdownで`を``で囲む方法。
    `を\でエスケープしてみても駄目だった。
#### オブジェクトリテラル
- 識別子とは、文字列の値という認識で会っているか。
  <span style="color:red">識別子（Identifier）は、変数名、関数名、プロパティ名など、プログラム内で何かを識別するための名前のこと。</span>
#### 正規表現リテラル
- 正規表現をリテラルで書かない方法もある？
`````javascript
// リテラルで書く方法
const regex1 = /\d+/;

// コンストラクタで書く方法
const regex2 = new RegExp("\\d+");

// どちらも同じ意味
console.log(regex1.test("123"));  // true
console.log(regex2.test("123"));  // true
`````
- 正規表現の変数を定義したらboolean型になる？
  <span style="color:red">正規表現はobject形で、test()メソッドの返り値がboolean</span>

`````javascript
const regex = /\d+/;
console.log(typeof regex);  // "object"

// test()メソッドの返り値がboolean
console.log(regex.test("123"));  // true（boolean型）
console.log(typeof regex.test("123"));  // "boolean"
`````

**説明**：
- 正規表現自体は**RegExpオブジェクト**（object型）
- `test()`メソッドの**返り値**がboolean型
- 
---

<!-- 2025_11_04 -->
## 6 演算子
演算子には二項演算子と単項演算子がある。

### 二項演算子
#### プラス演算子（`+`）
2つの数値を加算する演算子。
```JS
console.log(1 + 1); // => 2
```

#### 文字列結合演算子（`+`）
2つの文字列を結合する演算子。
```JS
const value = "文字列" + "結合";
console.log(value); // => "文字列結合"
```

#### マイナス演算子（`-`）
2つの数値を減算する演算子。
```JS
console.log(1 - 1); // => 0
console.log(10 - 0.5); // => 9.5
```

#### 乗算演算子（`*`）
2つの数値を乗算する演算子。
```JS
console.log(2 * 8); // => 16
console.log(10 * 0.5); // => 5
```

#### 除算演算子（`/`）
2つの数値を除算する演算子。
```JS
console.log(8 / 2); // => 4
console.log(10 / 0.5); // => 20
```

#### 剰余演算子（`%`）
```JS
console.log(8 % 2); // => 0
console.log(9 % 2); // => 1
console.log(10 % 0.5); // => 0
console.log(10 % 4.5); // => 1
```

#### [ES2016] べき乗演算子（`**`）
2つの数値のべき乗を求める演算子。
```JS
// べき乗演算子（ES2016）で2の4乗を計算
console.log(2 ** 4); // => 16
```
同じ動きをする`Math.pow`静的メソッドがある。
```JS
console.log(Math.pow(2, 4)); // => 16
```

### 単項演算子（算術）
1つのオペランドを受け取り処理する演算子。

#### 単項プラス演算子（`+`）
単項演算子の`+`はオペランドを数値に変換する。
```JS
console.log(+"1"); // => 1
```
- 以下のように文字列は数値に変換できず、`Nan`となる。
```JS
console.log(+"1"); // => 1
```
- `NaN`はNot-a-Numberの略称で、数値ではないがNumber型の値を表現している。
- `NaN`はどの値とも（NaN自身に対しても）一致しない特性があり、`Number.isNaN`静的メソッドを使うことで`NaN`の判定を行える。
```JS
// 自分自身とも一致しない
console.log(NaN === NaN); // => false
// Number型である
console.log(typeof NaN); // => "number"
// Number.isNaNでNaNかどうかを判定
console.log(Number.isNaN(NaN)); // => true
```
- しかし、文字列から数値の返還に単項プラス演算子を使うべきではない。
`Number`コンストラクタ関数や`ParseInt`関数などの明示的な返還方法が存在するため。

#### 単項マイナス演算子（`-`）
- 単項マイナス演算子はマイナスの数値を反転できる。
```JS
console.log(-(-1)); // => 1
```
- 単項マイナス演算子も文字列などを数値へ変換できる。
```JS
console.log(-"1"); // => -1
```

#### インクリメント演算子（`++`）
オペランドの数値を`+1`する演算子。

#### デクリメント演算子（`--`）
オペランドの数値を`-1`する演算子。

### 比較演算子
オペランド同士の値を比較し、真偽値を返す演算子。

#### 厳密等価演算子（`===`）
同じ型で同じ値の時に`true`を返す。

#### 厳密不等価演算子（`!==`）
異なる方または異なる値である場合に`true`を返す。

#### 等価演算子（`==`）
同じデータ型のオペランドを比較する場合は、厳密等価演算子と同じ結果になるが、異なる型の場合**暗黙的な型変換**をしてから比較する。

#### 不等価演算子（`!=`）
等価演算子同様、暗黙的な型変換をしてから比較する。

#### 大なり演算子/より大きい（`>`）
左オペランドが右オペランドより大きい場合、`true`を返す。

#### 大なりいオール演算子/以上（`>=`）
左オペランドが右オペランドより大きいまたは等しいならば、`true`を返す。

#### 小なり演算子/より小さい（`<`）
左オペランドが右オペランドより小さいならば、`true`を返す。

#### 小なりイコール演算子/以下（`<=`）
小なり演算子または等しいならば`true`を返す。

### ビット演算子（ToDo）

### [ES2015] 分割代入（Destructuring assignment）
配列やオブジェクトを分割して一つの変数にできるもの。

### 論理演算子
基本的に真偽値を扱う演算子。

#### AND演算子（`&&`）
左辺の値が`true`なら、右辺の評価結果を返す。
`false`の場合は、右辺が実行されない。
    →**短絡評価**

#### OR演算子（`||`）
左辺の値の評価結果が`true`ならば、そのまま左辺を返し、`false`だったら、右辺の評価結果を返す。

#### NOT演算子（`!`）
オペランドの評価が`true`ならば`false`を返し、`false`ならば`true`を返す。

### [ES2020] Nullish coalescing演算子(??)
左辺の値が**nullish**であるならば、右辺の評価結果を返します。
nullish → 評価結果が`null`または`undefined`となる値のこと。

#### 卒業制作
予約フォームに入力した値のチェックをするために、以下のように使った記憶がある。
```js
const user_name = "入力値" ?? "名前がありません。";
```

### 条件（三項）演算子（`?`と`:`）（ToDo：よくわからなかった）
```js
条件式?Trueの時処理する式：Falseの時処理する式；
```

### グループ化演算子（`(`と`)`）
`()`の中の計算を先に行うという演算子。

### カンマ演算子（`,`）
区切った式を左から順に評価し、最後の式の評価結果を返す。
```js
const a = 1, b = 2, c = a + b;
console.log(c); // => 3
```

### まとめ
- 演算子は、計算や値を評価する時に使われるもの
- 数学で使われる四則演算や、プログラミング特有の論理演算があり、JavaScript特有の厳密等価演算子、厳密不等価演算子がある。

## 7 暗黙的な型変換
### さまざまな暗黙的な型変換
暗黙的な型変換は結果の予想が難しい。
- 2つの値までなら結果の様相がまだできる
- 以下のように3つになると予測が難しくなる
    - おそらく左オペランドから演算されるから上２つは文字列結合、一番下は最初だけ数値計算して文字列結合をしていると予想。
```js
const x = 1, y = "2", z = 3;
console.log(x + y + z); // => "123"
console.log(y + x + z); // => "213"
console.log(x + z + y); // => "42"
```
### 明示的な型変換
プリミティブ型へ明示的な型変換をする方法

#### 任意の値から真偽値
- 以下のfalsyな値は`false`に変換される
  - `false`
  - `undefined`
  - `null`
  - `0`
  - `0n`
  - `NaN`
  - `""`
- falsyな値以外は`true`に変換される

#### 数値から文字列
Stringコンストラクタ関数で、数値以外にもいろいろな値を文字列へと変換できる
しかし、配列にっは`join`メソッド、オブジェクトには`JSON.stringify`静的メソッドなどの方法があるため、プリミティブ型に対してのみとどめるべき
```js
String("str"); // => "str"
String(true); // => "true"
String(null); // => "null"
String(undefined); // => "undefined"
String(Symbol("シンボルの説明文")); // => "Symbol(シンボルの説明文)"
// プリミティブ型ではない値の場合
String([1, 2, 3]); // => "1,2,3"
String({ key: "value" }); // => "[object Object]"
String(function() {}); // "function() {}"
```

#### シンボルから文字列
ES2015で追加されたプリミティブ型であるシンボルは暗黙的に変換できないが、
```js
"文字列と" + Symbol("シンボルの説明"); // => TypeError: can't convert symbol to string
```
以下のようにStringコンストラクタ関数を使うことでシンボルを明示的に文字列化することができます。

#### 文字列から数値
- 文字列から数値に変換するにはNumberコンストラクタ関数を使う。
```js
// ユーザー入力を文字列として受け取る
const input = window.prompt("数字を入力してください", "42");
// 文字列を数値に変換する
const num = Number(input);
console.log(typeof num); // => "number"
console.log(num); // 入力された文字列を数値に変換したもの
```

- 文字列から数字を取り出して変換する関数（`Number.parseInt`、`Number.parseFloat`）も使える。
```js
// "1"をパースして10進数として取り出す
console.log(Number.parseInt("1", 10)); // => 1
// 余計な文字は無視してパースした結果を返す
console.log(Number.parseInt("42px", 10)); // => 42
console.log(Number.parseInt("10.5", 10)); // => 10
// 文字列をパースして浮動小数点数として取り出す
console.log(Number.parseFloat("1")); // => 1
console.log(Number.parseFloat("42.5px")); // => 42.5
console.log(Number.parseFloat("10.5")); // => 10.5
```

#### NanはNot a NumberだけどNumber型

- NaNは自分自身と一致しない
```js
function isNaN(x) {
    // NaNは自分自身と一致しない
    return x !== x;
}
console.log(isNaN(1)); // => false
console.log(isNaN("str")); // => false
console.log(isNaN({})); // => false
console.log(isNaN([])); // => false
console.log(isNaN(NaN)); // => true
```

#### 疑問点
- Symbolとは何か？
  - 一意性：同じ説明文でも別のSymbolは異なる値
  - 不変：作成後、値を変更できない
  - 列挙されない：`for...in`などで列挙されない

<!-- 2025/11/08 -->
## 8 関数と宣言

### ２種類の関数がある
- functionキーワード`function 関数名(仮引数1,仮引数2){}`
```js
// 関数宣言
function 関数名(仮引数1, 仮引数2) {
    // 関数が呼び出されたときの処理
    // ...
    return 関数の返り値;
}
// 関数呼び出し
const 関数の結果 = 関数名(引数1, 引数2);
console.log(関数の結果); // => 関数の返り値
```
### [ES2015]デフォルト引数
以下のように関数の仮引数にデフォルト値を渡すことができる。
```js
function echo(x = "デフォルト値") {
    return x;
}

console.log(echo(1)); // => 1
console.log(echo()); // => "デフォルト値"
```

#### 疑問
- 仮引数にデフォルト値を渡すのは初期値の代入みたいなものの認識。

### 可変長引数
`Math.max(...args)`は引数を何個でも受け取り、その中で最大の数値を返す関数

#### [ES2015] Rest parameters
仮引数名の前に`...`を付けた仮引数のことで、関数に渡された値が配列に代入される。
```js
function fn(arg1, ...restArgs) {
    console.log(arg1); // => "a"
    console.log(restArgs); // => ["b", "c"]
}
fn("a", "b", "c");
```

##### Spread構文
配列の前に`...`を付けた構文のことで、関数には配列の値を展開したものが引数として渡されます。
```js
function fn(x, y, z) {
    console.log(x); // => 1
    console.log(y); // => 2
    console.log(z); // => 3
}
const array = [1, 2, 3];
// Spread構文で配列を引数に展開して関数を呼び出す
fn(...array);
// 次のように書いたのと同じ意味
fn(array[0], array[1], array[2]);
```

##### `arguments`
可変長を扱う方法として、関数の中で飲み参照できる特殊な変数。
- **Array-like**なオブジェクト
- 配列のようにインデックスで要素へアクセスができる
- `Array`ではないので`Array`のメソッドは利用できない
- Rest parametersが利用できる環境では、以下の理由から使わないほうが良い
    - Arrow Functionで使えない
    - Arrayのメソッドがつかえない
    - 関数が可変長引数を受け付けるのかを仮引数だけをみて判断できない
```js
function fn() {
    // `arguments`はインデックスを指定して各要素にアクセスできる
    console.log(arguments[0]); // => "a"
    console.log(arguments[1]); // => "b"
    console.log(arguments[2]); // => "c"
}
fn("a", "b", "c");
```


### 疑問点
- Arrayメソッドとはなんのことか
- arguments変数は、ブラックボックスなのでどういう値が渡っているか仮引数を見てもわからないという認識

<!-- 2025/11/09 -->
### 関数の引数と分割代入
分割代入（Destructuring assignment）は、オブジェクトや配列からプロパティを取り出し変数として定義しなおす構文。

- 関数の引数には、`{}`で囲むことでオブジェクトのプロパティを呼び出すことができる
```js
function printUserId({ id }) {
    console.log(id); // => 42
    }
    const user = {
        id: 42
    };
    printUserId(user);
```

- `=`を使って変数にオブジェクトから対応するプロパティを代入できる。
```js
const user = {
    id: 42
};
// オブジェクトの分割代入
const { id } = user;
console.log(id); // => 42
// 関数の引数の分割代入
function printUserId({ id }) {
    console.log(id); // => 42
}
printUserId(user);
```

- 配列にも分割代入ができる
```js
function print([first, second]) {
    console.log(first); // => 1
    console.log(second); // => 2
}
const array = [1, 2];
print(array);
```

#### 理解度（まとめ）
- オブジェクトのプロパティを関数の引数に入れることで分割される
- 配列の変数を関数で呼び出すことによって分割される

#### 理解度（添削版）
- オブジェクトの分割代入：オブジェクトから特定のプロパティを取り出して、個別の変数として使える
- 配列の分割代入：配列から特定の要素を取り出して、個別の変数として使える
- 関数の引数での分割代入：関数呼び出し時に、オブジェクトや配列を分割して受け取れる


<!-- 2025/11/10 -->
### 関数はオブジェクト
JavaScriptで関数は、関数オブジェクトとも呼ばれるが、オブジェクトと異なり関数名に`()`を付けることでまとめた処理を呼び出すことができる。
- 関数はほかの値と同じように変数へ代入したり、関数の引数として渡せる。
→**ファーストクラスファンクション（第一級関数 ）**
```js
function fn() {
    console.log("fnが呼び出されました");
}
// 関数`fn`を`myFunc`変数に代入している
const myFunc = fn;
myFunc();
```

### 関数式
関数を値として代入している式
- functionキーワードの右辺に書く関数名は省略できる。
→名前を持たない関数（無名関数　または匿名関数）と呼ぶ
```js
// 関数式は変数名で参照できるため、"関数名"を省略できる
const 変数名 = function() {
};
// 関数宣言では"関数名"は省略できない
function 関数名() {
}
```
- 関数式でも名前をつけることができるが、関数の外から呼ぶことはできないので、再帰的に関数を呼び出す際に使われる。

### [ES2015] Arrow Function
関数式にはfunctionキーワード以外にも、無名関数を定義するArrow Functionと呼ばれる書き方がある。
```js
// Arrow Functionを使った関数定義
const 変数名 = () => {
    // 関数を呼び出したときの処理
    // ...
    return 関数の返す値;
};
```

#### Arrow Functionの省略記法
- 仮引数が１つの時は`()`を小楽できる
- 関数の処理が１つの式である場合、ブロックとreturn分を省略できる
  - その式の評価結果をreturnの返り値に暗黙的に変えてくれる
```js
// 仮引数の数と定義
const fnA = () => { /* 仮引数がないとき */ };
const fnB = (x) => { /* 仮引数が1つのみのとき */ };
const fnC = x => { /* 仮引数が1つのみのときは()を省略可能 */ };
const fnD = (x, y) => { /* 仮引数が複数のとき */ };
// 値の返し方
// 次の２つの定義は同じ意味となる
const mulA = x => { return x * x; }; // ブロックの中でreturn
const mulB = x => x * x;            // 1行のみの場合はreturnとブロックを省略できる
```

#### Arrow Functionの特徴
- 無名関数
- thisが静的に決定できる
- `function`キーワードに比べて短い
- `new`できない（コンストラクタ関数ではない）
- `arguments`変数を参照できない

####　コールバック関数
引数として渡される関数のことを`コールバック関数`と呼ぶ
コールバック関数を引数として使う関数やメソッドを`高階関数`とよぶ
- 以下のように`forEach`メソッドはコールバック関数を引数として受け取る高階関数。
```js
const array = [1, 2, 3];
const output = (value) => {
    console.log(value);
};
array.forEach(output);
// 次のように実行しているのと同じ
// output(1); => 1
// output(2); => 2
// output(3); => 3
```
- 以下のようにファストクラスということを利用して、コールバック関数となる無名関数をその場で定義して渡している

#### メソッド
オブジェクトのプロパティである関数をメソッドと呼ぶ。
- JavaScriptにおいて、関数とメソッドの機能的な違いはないが分かりやすくするために呼び方を区別する。

#### [コラム] 同じ名前の関数宣言は上書きされる
`function`キーワードや`var`キーワードを使った関数式で上書きされてしまうので、`const`や`let`でエラーを出したほうが確実性が上がる（意図しない上書きが減る）


##### [ES2015] メソッドの短縮記法
オブジェクトリテラル内で、メソッドを書くことができる
```js
const obj = {
    method() {
        return "this is method";
    }
};
console.log(obj.method()); // => "this is method"
```

#### 疑問点
  - コールバック関数は同じ関数を再帰的に呼ぶこと？
  - JavaScriptの関数宣言は、Javaのように同じ名前で引数あり、引数なしコンストラクタのようにオーバーロードできないということ？

#### 使う頻度
arrow function：★★★★★
function：★★★☆☆

#### まとめ
- 関数式には、functionとarrow functionの書き方がある
- arrow function はargumentsが使えないので、人による解釈や実装のちがいが生まれにくくなるので、メリットが大きい

## 9 文と式（ToDo）

<!-- 2025_11_13 -->
## 10 条件分岐
### if文
- `{}`を省略できる
- falsyではない値は実行される
```js
const fnc = (x) => {
    if(x % 2 === 0){
        console.log("偶数")
    }else{
        console.log("奇数")
    }
};
fnc(5);
```
出力
```js
奇数
```

### else if文
```js
const version = "ES6";
if(version === "ES5"){
    console.log("ECMAScript 5");
}else if(version === "ES6"){
    console.log("ECMAScript 2015");
}else if(version === "ES7"){
    console.log("ECMAScript 2016");
}else{
    console.log("知らないバージョンです");
}
```
出力
```js
ECMAScript 2015
```

### else文
```js
const year = new Date().getFullYear();
if(year % 4 === 0 && year % 100 !== 0 && year % 400 === 0){
    console.log(`${year}年はうるう年です。`);
}else{
    console.log(`${year}年はうるう年ではありません。`);
}
```
出力
```js
2025年はうるう年ではありません。
```

### ネストしたif文

### switch文
```js
function getECMAScriptName(version) {
    switch (version){
        case "ES5":
            return "ECMAScript 5";
        case "ES6":
            return "ECMAScript 2015";
        case "ES7":
            return "ECMAScript 2016";
        default:
            return "知らないバージョンです。";
    }
}
```
出力
```js
ECMAScript 2016
```

<!-- 2025-11-14 -->

## 11 ループと反復処理

### while文
繰り返しループする処理
```js
let x = 0;
while(x < 10){
    console.log(x);
    x++;
}
```
出力
```
0
main.js:266 1
main.js:266 2
main.js:266 3
main.js:266 4
main.js:266 5
main.js:266 6
main.js:266 7
main.js:266 8
main.js:266 9
```

### do while文
先にコードを実行してからループ条件に入る処理
```js
const x = 1000;
do {
    console.log(x); // => 1000
} while (x < 10);
```
### for文
```js
//for文
for (let y = 0; y < 10; y++){
    console.log(y);
}
```
出力
```js
//whileと同じ
```

### 配列の`forEach`メソッド
for文とほぼ同じ
- `forEach`メソッドのコールバック関数は、配列の要素を順番に渡される
```js
const sum = (array) => {
    let result = 0;
    array.forEach(num => {
        result += num;
    });
    return result;
};

console.log(sum([1, 2, 3, 4, 5]));
```

### 配列の`some`メソッド
配列の中に一つ以上任意の要素が含まれていたら`true`を返す
```js
const array = [1, 5, 10];
const isEvenIncluded = (inputArray) =>{
    // const numJudge = inputArray.some(num => {
    //     return num % 2 === 0;
    // });
    const numJudge = inputArray.some(num => num % 2 === 0);
    console.log("numJudgeの値:", numJudge);  // ← これを追加
    console.log("numJudgeの型:", typeof numJudge);  // ← これも
    if(numJudge === true){
        return "配列に偶数が含まれます。";
    }
};

console.log(isEvenIncluded(array));
```
出力
```js
配列に偶数が含まれます。
```

### 疑問点(11/14)
- forEachメソッドは、()内で定義した変数に、配列の要素を順番に渡すというにんしきであってますか？

<!-- 2025_11_15 -->
### continue文
while、do-while、forの中で、continueを書いた後の処理をスキップする
```js
const isEven = (num) => num % 2 === 0;
const filterEven = (numbers) => {
    const result = [];
    for (let i = 0; i < numbers.length; i++){
        const num = numbers[i];
        if(!isEven(num)){
            continue;
        }
        result.push(num);
    }
    return result;
};
const array = [1, 5, 10, 15, 20];
console.log(filterEven(array));
```

### 配列の`filter`メソッド
配列から特定の値だけ集めた新しい配列を作る
```js
const array = [1, 5, 10, 15, 20];
const isEven = (num) => num % 2 === 0;
const result = array.filter(isEven);
console.log(result);
```

### for...in文
オブジェクトのプロパティに対して、反復処理を行う
しかし、親オブジェクトのプロパティまで列挙される問題がある。
```js
const obj = {
    "a": 1,
    "b": 2,
    "c": 3
};

for(const key in obj){
    const value = obj[key];
    console.log(`key:${key}, value:${value}`);
}
```
- 安全なオブジェクトのプロパティを列挙する方法
```js
Object.keys(obj).forEach(key => {
    const value = obj[key];
    console.log(`key:${key}, value:${value}`);
})
```
出力
```js
1
main.js:428 2
main.js:428 3
```

### for...of文
iterableオブジェクト（Arrayなど）に対して、反復処理を行う
```js
Object.keys(obj).forEach(key => {
    const value = obj[key];
    console.log(`key:${key}, value:${value}`);
});

const array = [1, 2, 3];
for(const value of array){
    console.log(value);
}

const array2 = "あいうえお";
for(const value of array2){
    console.log(value);
}
```
出力
```js
あ
main.js:433 い
main.js:433 う
main.js:433 え
main.js:433 お
```


### 疑問点
- filterなどのコールバック関数になぜisEvenだけで呼べるんですか？
  isEven()ではないのですか？
- for...in文で親オブジェクトまで列挙される問題が想像できません。どんな時ですか？

### まとめ
- forEachメソッドは、配列の要素をすべて止まらずに取得する点においてはfor文と同じ処理ができる
- `{}`で囲まれているものは関数なのでreturnが必要
- 関数を省略する時は`{}`は使わない

<!-- 2025-11-26 -->
## 12 オブジェクト
キーとバリューがついになったもの

- newを書くことで空のオブジェクトを作ることができる

### プロパティへのアクセス

#### ドット記法`.`
- `.`の後にkeyをつける
```Js
obj.key; // OK
// プロパティ名が数字から始まる識別子は利用できない
obj.123; // NG
// プロパティ名にハイフンを含む識別子は利用できない
obj.my-prop; // NG
```

#### ブラケット記法`[]`
- keyを`[]`の中に書く
```Js
const obj = {
    key: "value",
    123: 456,
    "my-key": "my-value"
};

console.log(obj["key"]); // => "value"
// プロパティ名が数字からはじまる識別子も利用できる
console.log(obj[123]); // => 456
// プロパティ名は暗黙的に文字列に変換されているため、次も同じプロパティを参照している
console.log(obj["123"]); // => 456
// プロパティ名にハイフンを含む識別子も利用できる
console.log(obj["my-key"]); // => "my-value"
```

- プロパティ名に変数をブラケット記法で指定
```Js
const languages = {
    ja: "日本語",
    en: "英語"
};
const myLang = "ja";
console.log(languages[myLang]); // => "日本語"
```

### [ES2015]オブジェクトと分割代入
オブジェクトのプロパティを変数として定義しなおすことができる
```Js
const languages = {
    ja: "日本語",
    en: "英語"
};
const { ja, en } = languages;
console.log(ja); // => "日本語"
console.log(en); // => "英語"
```

### プロパティの追加
#### ドット記法の追加
`obj.key`を左辺に指定することで`obj`オブジェクトに右辺の値を代入することができる
```Js
// 空のオブジェクト
const obj = {};
// `key`プロパティを追加して値を代入
obj.key = "value";
console.log(obj.key); // => "value"
```

#### ブラケット記法
`obj[key]`に値を代入
- ドット記法が使えない以下の場合も使える
  - 変数
  - 変数の識別子として扱えない文字列
  - Symbol
```Js
const key = "key-string";
const obj = {};
// `key`の評価結果 "key-string" をプロパティ名に利用
obj[key] = "value of key";
// 取り出すときも同じく`key`変数を利用
console.log(obj[key]); // => "value of key"
```

#### Computed property names
オブジェクトリテラル内でのブラケット記法を使ったプロパティ名
```Js
const key = "key-string";
// Computed Propertyで`key`の評価結果 "key-string" をプロパティ名に利用
const obj = {
    [key]: "value"
};
console.log(obj[key]); // => "value"
```


### プロパティの削除
delete演算子でオブジェクトのプロパティを削除できる
```Js
const obj = {
    key1: "value1",
    key2: "value2"
};
// key1プロパティを削除
delete obj.key1;
// key1プロパティが削除されている
console.log(obj); // => { "key2": "value2" }
```

<!-- 2025-11-27 -->
### プロパティの存在確認
- JavaScriptでは存在しないプロパティアクセスした場合に例外が発生しない
- プロパティの確認方法は以下の通りあるが、プロパティが存在するか判定するには`in`演算子か`Object.hasOwn`静的メソッドを使う
  - undefinedとの比較
  - in演算子
  - Object.hasOwn静的メソッド[ES2022]
  - Object.prototype.hasOwnPropertyメソッド

#### undefinedとの比較
プロパティそのものが存在しているかわからない
```Js
const obj = {
    key: "value"
};
// `key`プロパティが`undefined`ではないなら、プロパティが存在する?
if (obj.key !== undefined) {
    // `key`プロパティが存在する?ときの処理
    console.log("`key`プロパティの値は`undefined`ではない");
}
```

#### in演算子を使う
指定したオブジェクト上に指定したプロパティがあるかを判定し、真偽値を返す
```Js
const obj = { key: undefined };
// `key`プロパティを持っているならtrue
if ("key" in obj) {
    console.log("`key`プロパティは存在する");
}
```

#### `Object.hasOwn`静的メソッド
対象のオブジェクトが指定したプロパティを持っているかを判定できる
- 引数に渡すもの
    `Object.hasOwn(obj, "プロパティ名")`
```Js
const obj = { key: undefined };
// `obj`が`key`プロパティを持っているならtrueとなる
if (Object.hasOwn(obj, "key")) {
    console.log("`obj`は`key`プロパティを持っている");
}
```

#### `Object.prototype.haOwnProperty`メソッド
[ES2022]`Object.hasOwn`によく似ているメソッド
しかし、オブジェクトのインスタンスから呼び出す点が異なる
```Js
const obj = { key: undefined };
// `obj`が`key`プロパティを持っているならtrueとなる
if (obj.hasOwnProperty("key")) {
    console.log("`obj`は`key`プロパティを持っている");
}
```

### [ES2020] Optional chaining演算子（?.）
プロパティが存在するかが重要でない場合は、if文で`undefined`と比較してもよい
例えば、最終的にプロパティの値を取得したい場合など
- Optional chaining演算子は、左辺のオペランドがnullishの場合に、それ以上評価せずに`undefined`を返す
```Js
function printWidgetTitle(widget) {
    const title = widget?.window?.title ?? "未定義";
    console.log(`ウィジェットのタイトルは${title}です`);
}
printWidgetTitle({
    window: {
        title: "Book Viewer"
    }
}); // "ウィジェットのタイトルはBook Viewerです" と出力される
printWidgetTitle({
    // タイトルが定義されてない空のオブジェクト
}); // "ウィジェットのタイトルは未定義です" と出力される
```

- ブラケット記法でも書くことができる
`?.`だけの場合と異なる点は、プロパティが存在する場合に、そのプロパティの評価結果を返す
```Js
const languages = {
    ja: {
        hello: "こんにちは！"
    },
    en: {
        hello: "Hello!"
    }
};
const langJapanese = "ja";
const langKorean = "ko";
const messageKey = "hello";
// Optional chaining演算子（`?.`）とブラケット記法を組みわせた書き方
console.log(languages?.[langJapanese]?.[messageKey]); // => "こんにちは！"
// `languages`に`ko`プロパティが定義されていないため、`undefined`を返す
console.log(languages?.[langKorean]?.[messageKey]); // => undefined
```

### `toString`メソッド
オブジェクト自信を文字列化する
```Js
const obj = { key: "value" };
console.log(obj.toString()); // => "[object Object]"
// `String`コンストラクタ関数は`toString`メソッドを呼んでいる
console.log(String(obj)); // => "[object Object]"
```

### [コラム]オブジェクトのプロパティ名は文字列化される
オブジェクトのプロパティは基本的に文字列化されるが、Symbolだけ文字列化されない

### オブジェクトの静的メソッド
静的メソッド（スタティックメソッド）とは、インスタンス元となるオブジェクトから呼び出せるメソッドのこと

#### オブジェクトの列挙
- `Object.keys`静的メソッド: オブジェクトのプロパティ名の配列にして返す
- `Object.values`静的メソッド[ES2017]: オブジェクトの値の配列にして返す
- `Object.entries`静的メソッド[ES2017]: オブジェクトのプロパティ名と値の配列の配列を返す
```Js
const obj = {
    "one": 1,
    "two": 2,
    "three": 3
};
// `Object.keys`はキーを列挙した配列を返す
console.log(Object.keys(obj)); // => ["one", "two", "three"]
// `Object.values`は値を列挙した配列を返す
console.log(Object.values(obj)); // => [1, 2, 3]
// `Object.entries`は[キー, 値]の配列を返す
console.log(Object.entries(obj)); // => [["one", 1], ["two", 2], ["three", 3]]
```

### オブジェクトのマージと複製
`Object.assign`静的メソッド[ES2015]は、あるオブジェクトを別のオブジェクトに代入（assign）できる

#### オブジェクトのマージ
以下は新しく作った空のオブジェクトを`target`にしている
※ 既存のオブジェクトに入れることもできるが、空のオブジェクトのほうが安全
```Js
const objectA = { a: "a" };
const objectB = { b: "b" };
const merged = Object.assign({}, objectA, objectB);
console.log(merged); // => { a: "a", b: "b" }
```

#### [ES2018] オブジェクトのspread構文でのマージ
`Object.assign`と異なり必ず新しいオブジェクトを作成する
```Js
const objectA = { a: "a" };
const objectB = { b: "b" };
const merged = {
    ...objectA,
    ...objectB
};
console.log(merged); // => { a: "a", b: "b" }
```

#### オブジェクトの複製
新しく空のオブジェクトを作成し、そこへ既存のオブジェクトのプロパティをコピーする
- `Object.assign`静的メソッドが使えるs
```Js
// 引数の`obj`を浅く複製したオブジェクトを返す
const shallowClone = (obj) => {
    return Object.assign({}, obj);
};
const obj = { a: "a" };
const cloneObj = shallowClone(obj);
console.log(cloneObj); // => { a: "a" }
// オブジェクトを複製しているので、異なるオブジェクトとなる
console.log(obj === cloneObj); // => false
```

- しかしhallow copyになってしまうため、shallow copyを再帰的に複製してコピーしてdeep copyにしたほうが良い
```Js
// 引数の`obj`を浅く複製したオブジェクトを返す
const shallowClone = (obj) => {
    return Object.assign({}, obj);
};
// 引数の`obj`を深く複製したオブジェクトを返す
function deepClone(obj) {
    const newObj = shallowClone(obj);
    // プロパティがオブジェクト型であるなら、再帰的に複製する
    Object.keys(newObj)
        .filter(k => typeof newObj[k] === "object")
        .forEach(k => newObj[k] = deepClone(newObj[k]));
    return newObj;
}
const obj = {
    level: 1,
    nest: {
        level: 2
    }
};
const cloneObj = deepClone(obj);
// `nest`オブジェクトも再帰的に複製されている
console.log(cloneObj.nest === obj.nest); // => false
```

## 13 プロトタイプオブジェクト（ToDo）

<!-- 2025-11-17 -->
## 14 配列

### 配列の作成とアクセス(ToDo)


### 配列から要素を検索
配列から指定した要素を検索する目的
  - その要素のインデックスが欲しい時
  - その要素自体が欲しい時
  - その要素が含まれているかという真偽値が欲しい時

<!-- 2025-11-18 -->
#### インデックスを取得
- `indexOf`メソッド
  先頭から検索し最初に見つかったインデックスを返す
- `lastIndexOf`メソッド
  末尾から検索し最初に見つかったインデックスを返す

#### 条件に一致する要素を取得
- `findIndex`メソッド[ES2015]
  異なるオブジェクトでも値が同じものを探すことができる
```js
  const colors = [
    {"color": "red"},
    {"color": "green"},
    {"color": "blue"}
];
const indexOfBlue = colors.findIndex((obj) =>{
    return obj.color == "blue";
});
console.log(indexOfBlue);
console.log(colors[indexOfBlue]);
```
- `findLastIdex`は条件に一致する末尾のインデックスを返す

#### 指定範囲の要素を取得
arrayの`slice`メソッドで指定範囲の要素を取り出し、新しい配列を返す
```js
const array = ["A", "B", "C", "D", "E"];

console.log(array.slice(0, 2));
```

#### 真偽値を取得
指定した要素が配列に含まれているか**だけ**を知りたいとき
- `includes`メソッド[ES2016]
  指定要素が配列に含まれいれば`true`を返す
```Js
const array = ["Java", "JavaScript", "Ruby"];

if(array.includes("JavaScript")){
    console.log(("配列にJavaScriptが含まれている"));
}
console.log(array.includes("JavaScript"));
```
- `some`メソッド
  異なるオブジェクトでも値が同じものを探すことができる
  コールバック関数にマッチする要素がある場合`true`を返す
```Js
const colors = [
    { "color": "red" },
    { "color": "green" },
    { "color": "blue" }
];
const isIncludedBlueColor = colors.some(obj => {
    return obj.color === "blue";
});
console.log(isIncludedBlueColor);
```

### 追加と削除
JavaScriptの配列は基本可変長のため、作成後の配列に要素を追加、削除できる

- `push`メソッドで配列の末尾に要素を**追加**
- `pop`メソッドで配列の末尾から要素を**削除**
```Js
const array = ["A", "B", "C"];
array.push("D", "E");
console.log(array);
const poppedItem = array.pop();
console.log(poppedItem);
console.log(array);
```

- `unshift`メソッドで配列の先頭に要素を**追加**
- `shift`メソッドで配列の先頭から要素を**削除**
```Js
const array = ["A", "B", "C"];
array.unshift(0);
console.log(array);
const shiftedItem = array.shift();
console.log(array);
```

### 配列同士の結合
- `concat`メソッドで配列と配列を結合した新しい配列を作成できる
```Js
//配列同士を結合
const array = ["A", "B", "C"];
const array2 = ["D", "E"];
//下でもう一度結合するためにletにしている
let newArray = array.concat(array2);
console.log(newArray);
//任意の値を結合
newArray = array.concat("新しい要素");
console.log(newArray);
```

### [ES2015]配列の展開
`...`（Spread構文）を使うことで、配列リテラル中に既存の配列を展開できる
- concatと同じ結果だが、配列リテラル中の任意の位置に配列を展開できる点が違う
```Js
//spread構文の結合
const array = ["A", "B", "C"];
const newArray = ["X", "Y", "Z", ...array];
//concatの結合
const newArrayConcat = ["X", "Y", "Z"].concat(array);
console.log(newArray);
console.log(newArrayConcat);
//任意の位置
const newArray2 = ["X", ...array, "Y", "Z"];
console.log(newArray2);
```


### 疑問点
- letのarrayにconcatメソッドで結合した場合、また新しくconcatしたら値が置き換えられる？
→concatは新しい配列を返すからYes
追加し続けたいときは以下のように`newArray`に`concat`する
```Js
let newArray = array.concat(array2);  // ["A", "B", "C", "D", "E"]
newArray = newArray.concat("新しい要素");  // ["A", "B", "C", "D", "E", "新しい要素"]
```

### まとめ（2025/11/18）
- 検索
  - `indexOf`メソッドは、先頭から見つけた要素のインデックスを返す
  - `lastIndexOf`メソッドは、末尾から見つけた要素のインデックスを返す
  - `findIndex`メソッド[ES2015]は条件に一致する先頭のインデックスを返す
  - `findLastIdex`は条件に一致する末尾のインデックスを返す
**違い：**indesOf２つは異なるオブジェクトでは探せないが、find2つは異なるオブジェクトを跨いで検索できる
- 真偽値
  - `includes`メソッド[ES2016]は指定要素が配列に含まれていれば`true`を返す
  - `some`メソッドは指定要素が配列にh組まれていれば`true`を返す
**違い：**includesは異なるオブジェクトでは判断できないが、someは異なるオブジェクトを跨いで判断できる
- 配列に要素を追加
  - `push`メソッドで配列の**末尾**に要素を**追加**
  - `unshift`メソッドで配列の**先頭**に要素を**追加**
- 配列の要素を削除
  - `pop`メソッドで配列の**末尾**から要素を**削除**
  - `shift`メソッドで配列の**先頭**から要素を**削除**
- 配列の結合
  - `concat`メソッドで配列と配列を結合した新しい配列を作成できる
  - `...`spread構文を使えば配列中に配列を展開できる

<!-- 2025-11-19 -->
### 配列から要素を削除
`Array.prototype.splice`
`splice`メソッドは、配列の任意のインデックス要素を削除できる
```Js
///任意の要素を削除
const array = ["a", "b", "c",];
const arrayConcat = ["D", "E", "F"];
const arrayRM = array.splice(0, 1, ...arrayConcat);
console.log(arrayRM);
console.log(array);
```
- またSpread構文で削除した箇所に配列を展開することができる。
出力
```Js
['a']
['D', 'E', 'F', 'b', 'c']
```

#### `length`プロパティへの代入
lengthに0を代入すると全要素を削除することができる
**理由：**oを代入することで、ガーベジコレクションによりメモリから解放される
```Js
//配列の要素をすべて削除
// spliceメソッドを使う方法
const array = ["a", "b", "c",];
array.splice(0, array.length);
console.log(array);
//lengthを0にする方法
const array2 = ["a", "b", "c",];
array2.length = 0;
console.log(array2);
```
#### 空の配列を代入
```Js
//空の配列を代入
let array = [1, 2, 3];
console.log(array.length);
array = [];
console.log(array.length);
```

### まとめ（2025/11/19）
- `concat`と`...`（spread構文）はどちらも、配列に配列を追加することができるが、concatは**末尾に追加**、spread構文は**任意のインデックスに追加**することができる
- 配列から要素を削除する方法
  - popは末尾、shiftは先頭を削除するが、`splice`メソッドは任意の場所・範囲を削除できる。
  - ...spread構文で削除したインデックスに置き換えることができる
  - 配列からすべての要素を削除する方法
    - spliceメソッドにインデックス0から配列の長さの範囲を指定することで全削除できる
    - 配列のlengthの値に0を代入するとすべて削除される
    - let配列に、空の配列を代入することで、ガーベジコレクションされ全削除できる

<!-- 2025/11/20 -->
### 破壊的なメソッドと非破壊的なメソッド
目的：意図しない結果を避けるため

#### 破壊的なメソッド（Mutable Method）
配列を直接変更し、変更した配列を返す
```Js
const array  = ["A" , "B", "C"];
const result = array.push("D");
console.log(result);
console.log(array);
```
出力
```Js
4
//元の値についかされている
['A', 'B', 'C', 'D']
```

#### 非破壊的なメソッド（Immutable Method）
配列のコピーを変更し、その変更したコピーを返す
```Js
const result = array.concat(["D", "E"]);
console.log(result);
console.log(array);
console.log(result === array);
```

#### 実務の注意点
破壊的であることはコメントがあったほうが良い
- 以下の関数は、arrayを変更し、その変更したものをnewArrayに渡しているのでどちらも同じ値になっている
```Js
//`array`の`index`番目の要素を削除知った配列を返す関数
//引数の`array`は破壊的に変更される
function removeAtIndex(array, index){
    array.splice(index, 1);
    console.log(array);     //デバック
    return array;
}
const array = ["A", "B", "C"];
const newArray = removeAtIndex(array, 1)
console.log(array);
console.log(newArray);
```
出力
```Js
['A', 'C']
['A', 'C']
['A', 'C']
```

#### 破壊的な関数を非破壊的な関数にする方法
- 関数内で`splice()`で別の変数にコピーする方法
```Js
// `array`の`index`番目の要素を削除した配列を返す関数
function removeAtIndex(array, index) {
    // コピーを作成してから変更する
    const copiedArray = array.slice();
    console.log(copiedArray);
    copiedArray.splice(index, 1);
    return copiedArray;
}
const array = ["A", "B", "C"];
// `array`から1番目の要素を削除した配列を取得
const newArray = removeAtIndex(array, 1);
console.log(newArray); // => ["A", "C"]
// 元の`array`には影響がない
console.log(array); // => ["A", "B", "C"]
```

- [ES2023]非破壊的なバージョン（`toSpliced`、`toReversed`、`toSorted`）を使う
```Js
// `array`の`index`番目の要素を削除した配列を返す関数
function removeAtIndex(array, index) {
    // コピーを作成してから変更する
    return array.toSpliced(index, 1);
}
const array = ["A", "B", "C"];
// `array`から1番目の要素を削除した配列を取得
const newArray = removeAtIndex(array, 1);
console.log(newArray); // => ["A", "C"]
// 元の`array`には影響がない
console.log(array); // => ["A", "B", "C"]
```

### まとめ（2025/11/20）
- 破壊的なメソッド
    配列そのものを変更するもの
- 非破壊的メソッド
    配列のコピーを変更するもの
- `slice`などで新しい変数にコピーすれば破壊的にならずに済む
- [ES2023]から非破壊的なメソッドが追加された
|破壊的な方法|	非破壊な方法|
|:---:|:---:|
|array[index] = item|	Array.prototype.with[ES2023]|
|Array.prototype.pop|	array.slice(0, -1)とarray.at(-1)[ES2022]|
|Array.prototype.push|	[...array, item][ES2015]|
|Array.prototype.splice|	Array.prototype.toSpliced[ES2023]|
|Array.prototype.reverse|	Array.prototype.toReversed[ES2023]|
|Array.prototype.sort|	Array.prototype.toSorted[ES2023]|
|Array.prototype.shift|	array.slice(1)とarray.at(0)[ES2022]|
|Array.prototype.unshift|	[item, ...array][ES2015]|
|Array.prototype.copyWithin[ES2015]|	なし|
|Array.prototype.fill[ES2015]|	なし|

<!-- 2025-11-21 -->
### 配列を反復処理するメソッド
どのメソッドも共通して引数にコールバック関数を受け取るため高階関数と呼ばれる

#### `Array.prototype.forEach`
配列の要素を先頭から順番にコールバック関数へ渡し、反復処理を行う

- コールバック関数に渡す引数
`forEach((要素, インデックス, 配列) => {});`
```Js
const array = [1, 2, 3];
array.forEach((currentValue, index, array) => {
    console.log(currentValue, index, array);
});
// コンソールの出力
// 1, 0, [1, 2, 3]
// 2, 1, [1, 2, 3]
// 3, 2, [1, 2, 3]
```

#### `Array.prototype.map`
配列の要素を順番にコールバック関数へ渡し、コールバック関数が返した値から新しい配列を返すメソッド（非破壊的メソッド）

- コールバック関数に渡す引数
`map((要素, インデックス, 配列) => {});`
```Js
const array = [1, 2, 3];
// 各要素に10を乗算した新しい配列を作成する
const newArray = array.map((currentValue, index, array) => {
    return currentValue * 10;
});
console.log(newArray); // => [10, 20, 30]
// 元の配列とは異なるインスタンス
console.log(array === newArray); // => false
```

#### `Array.prototype.filter`
配列の要素を順番にコールバック関数へ渡し、コールバック関数が`true`を返した要素だけを集めた新しい配列を返すメソッド（非破壊的メソッド）

- コールバック関数に渡す引数
`filter((要素, インデックス, 配列) => {});`
```Js
const array = [1, 2, 3];
// 奇数の値を持つ要素だけを集めた配列を返す
const newArray = array.filter((currentValue, index, array) => {
    return currentValue % 2 === 1;
});
console.log(newArray); // => [1, 3]
// 元の配列とは異なるインスタンス
console.log(array === newArray); // => false
```

#### `Array.prototype.reduce`
累積値（アキュムレータ）と配列の要素を順番にコールバック関数渡し、1つの累積値を返す

- コールバック関数に渡す引数
`reduce((累積値, 要素, インデックス, 配列) => {});`
```Js
const array = [1, 2, 3];
// すべての要素を加算した値を返す
// accumulatorの初期値は`0`
const totalValue = array.reduce((accumulator, currentValue, index, array) => {
    return accumulator + currentValue;
}, 0);
// 0 + 1 + 2 + 3という式の結果が返り値になる
console.log(totalValue); // => 6
```

### [ES2019] `Array.prototype.flat`メソッド
多次元配列をフラットな配列に変換（非破壊的なメソッド）
```Js
const array = [[["A"], "B"], "C"];
// 引数なしは1を指定した場合と同じ
console.log(array.flat()); // => [["A"], "B", "C"]
console.log(array.flat(1)); // => [["A"], "B", "C"]
console.log(array.flat(2)); // => ["A", "B", "C"]
// すべてをフラット化するにはInfinityを渡す
console.log(array.flat(Infinity)); // => ["A", "B", "C"]
```

### [ES2019] `Array.prototype.flatmap`メソッド
`map`してから`flat(1)`するのと同じ結果

- コールバック関数に渡す引数
`flatMap((要素, インデックス, 配列) => {})`
```Js
const array = [1, 2, 3];
// 各要素を2倍にしてから、その値を配列として返す
const doubled = array.flatMap((value) => {
    return [value, value * 2];
});
console.log(doubled); // => [1, 2, 2, 4, 3, 6]
```

### [ES2024] `Object.groupBy`静的メソッド
配列から数値やオブジェクトなど任意の値を作成できる

- 配列からオブジェクトを作成したいユースケース
  数値からなる配列の要素を奇数と偶数の配列に分けたいとき

```Js
const array = [1, 2, 3, 4, 5];
const grouped = Object.groupBy(array, (currentValue) => {
    // currentValueが偶数なら"even"、そうでないなら"odd"の配列に追加される
    return currentValue % 2 === 0 ? "even" : "odd";
});
console.log(grouped.even); // => [2, 4]
console.log(grouped.odd); // => [1, 3, 5]
```

### [コラム] Array-likeオブジェクト
配列のように扱えるが配列ではないオブジェクトのこと
しかし、Arrayのprototypeメソッドはもっていない
- `arguments`メソッド
```Js
function myFunc() {
    console.log(arguments[0]); // => "a"
    console.log(arguments[1]); // => "b"
    console.log(arguments[2]); // => "c"
    // 配列ではないため、配列のメソッドは持っていない
    console.log(typeof arguments.forEach); // => "undefined"
}
myFunc("a", "b", "c");
```

- Array.from静的メソッドでArray-likeオブジェクトを配列に変換してあつかうことができる
```Js
function myFunc() {
    // Array-likeオブジェクトを配列へ変換
    const argumentsArray = Array.from(arguments);
    console.log(Array.isArray(argumentsArray)); // => true
    // 配列のメソッドを利用できる
    argumentsArray.forEach(arg => {
        console.log(arg);
    });
}
myFunc("a", "b", "c");
```

### メソッドチェーンと高階関数
メソッドを呼び出した返り値に対してさらにメソッド呼び出しをするパターンのことをメソッドチェーンと言う
```JS
// ECMAScriptのバージョン名と発行年
const ECMAScriptVersions = [
    { name: "ECMAScript 1", year: 1997 },
    { name: "ECMAScript 2", year: 1998 },
    { name: "ECMAScript 3", year: 1999 },
    { name: "ECMAScript 5", year: 2009 },
    { name: "ECMAScript 5.1", year: 2011 },
    { name: "ECMAScript 2015", year: 2015 },
    { name: "ECMAScript 2016", year: 2016 },
    { name: "ECMAScript 2017", year: 2017 },
];
// メソッドチェーンで必要な加工処理を並べている
const versionNames = ECMAScriptVersions
    // 2000年以下のデータに絞り込み
    .filter(ECMAScript => ECMAScript.year <= 2000)
    // それぞれの要素から`name`プロパティを取り出す
    .map(ECMAScript => ECMAScript.name);
console.log(versionNames); // => ["ECMAScript 1", "ECMAScript 2", "ECMAScript 3"]
```

### 疑問点
- そもそも静的とはどういう意味か
- `forEach((要素, インデックス, 配列) => {});`のようにコールバック関数が渡されてるが、これは配列を渡せばプログラムが勝手にそれぞれ判断して値をとってくれる認識であっているか

### まとめ（2025/11/21）
- 配列には、配列を取り出したり絞り込んだりできるprototypeメソッドという便利なメソッドがある
- prototypeメソッドは破壊的メソッドと非破壊的メソッドが存在する
- メソッドチェーンを利用するとシンプルな書き方で分かりやすく表現できる

<!-- 2025-11-22 -->
## 15 文字列
**目的：**文字列を編集して自由に文字列を作れるようになること

### エスケープシーケンス

- `¥n` 改行
- `¥t` タブ
- `¥uXXXX` Code Unit(¥uと４桁のHexDigit)
- `¥u{X} ...` 
  `¥u{XXXXXX}` Code Point(¥u{}のカッコの中にHexDigit)

### 文字へのアクセス
  配列と同じようにインデックスでアクセスできる

#### [ES2022] `String.prototype.at`
Arrayのatメソッドと同じように、相対的なインデックスを渡してその位置の文字へアクセスできる

### 文字列とは
- コンピュータのメモリ上に文字列の「あ」と言った文字をそのまま保存できないため、0と1からなるビット列へ変換する必要がある。
- 文字からビット列へ変換することを符号化（エンコード）と呼ぶ。
- JavaScript（ECMAScript）は文字コードとして**Unicode**を採用しており、文字のエンコードに**UTF-16**を採用している。
- しかしJavaScriptファイル自体のエンコードはUTF-16以外の文字コードであっても問題ない。

### 文字列の分解と結合
- Stringの`split`メソッド
    文字列を配列へ分解
    - `/¥s+/`
      １つ以上のスペースにマッチする正規表現オブジェクトを作成する
- Arrayの`join`メソッド
    配列の要素を結合して文字列にする

### 文字列の一部を取得
- `slice`メソッド
  配列と同じ使い方
- `substring`メソッド
  - sliceメソッドとの違いは、位置にマイナスの値を指定した場合は常に`0`として扱われる
  - 第一関数の位置が第二関数の位置より大きい場合、第一関数と第二関数が入れ替わるという挙動をしてしまう

### 文字列の検索
大きく分けて文字列による検索と正規表現による検索がある

#### 文字列による検索
Stringオブジェクトには、指定した文字列で検索するメソッドが用意されている

##### 文字列によるインデックス
- `IndexOf`メソッド
    配列同様
- `lastIndexOf`メソッド
    配列同様

##### 文字列にマッチした文字列の取得
文字列を検索してマッチした文字列は、検索文字列そのもののため自明である。

##### 真偽値の取得
- `String.prototype.startsWith`
    検索文字列が先頭にあるかの真偽値を返す
- `String.prototype.endsWith`
    検索文字列が末尾にあるかの真偽値を返す
- `String.prototype.include`
    検索文字列を含むかの真偽値を返す

#### 正規表現オブジェクト
あるパターンにマッチするものを柔軟に検索できる
- 正規表現オブジェクト（RegExpオブジェクト）は、マッチする範囲を決める`パターン`と正規表現の検索モードを指定する`フラグ`の２つで構成される
- `¥`で特殊文字をエスケープできるが、`RegExp.escape`で安全にエスケープできるようになった

#### 正規表現リテラルと`RegExp`コンストラクタの違い
- 正規表現リテラル
ソースコードをロード（パース）した段階で正規表現のパターンが評価される
- `RegExp`コンストラクタ
通常の関数と同じように`RegExp`コンストラクタを呼び出すまで正規表現のパターンは評価されない

<!-- 2025-22-24 -->
### 正規表現による検索
`String`オブジェクトか`RegExp`オブジェクトを利用

#### 正規表現によるインデックスの取得
- `String.prototype.indexOf(検索文字列)`
  指定された文字列にマッチした箇所のインデックスを返す
- `String.prototype.search(/パターン/)`
  指定された正規表現のパターンにマッチした箇所のインデックスを返す

#### 正規表現によるマッチした文字列の取得
Stringの`match`メソッドと`matchAll`メソッド

##### マッチした文字列の取得
- 正規表現の`/パターン/`が`"文字列"`にマッチすると、文字列に関する情報を返す
- 文字列が見つからなかったら`null`を返す
- gフラグをつけたパターンで検索すると、マッチしたすべての文字列を返す
  - しかし、gフラグをつけなかったら最初に見つけたパターンしか返さない
  - gフラグをつけると`index`と`input`プロパティはない
  **理由：**複数箇所にマッチする場合では一つのindexプロパティでは意味が一意に決まらないから

- [ES2020]`matchAll`メソッド
  それぞれマッチした文字列ごとの情報を得るためのメソッド
  Itelatorで結果を返す
  - Itelatorオブジェクトは`for...of`構文で反復処理すると、Itelatorから値を一つずつ取り出す
```Js
const str = "ABC あいう DE えお";
const alphabetsPattern = /[a-zA-Z]+/g;
// matchAllはIteratorを返す
const matchesIterator = str.matchAll(alphabetsPattern);
for (const match of matchesIterator) {
    // マッチした要素ごとの情報を含んでいる
    console.log(`match: "${match[0]}", index: ${match.index}, input: "${match.input}"`);
}
// 次の順番でコンソールに出力される
// match: "ABC", index: 0, input: "ABC あいう DE えお"
// match: "DE", index: 8, input: "ABC あいう DE えお"
```

##### マッチした文字列の一部を取得
Stringの`match`メソッドと`matchAll`メソッドは、正規表現中で`/パターン1(パターン2)/`のようにカッコで囲んだ部分を取り出す**キャプチャリング**に対応している
- `match`メソッド
```Js
// "ECMAScript (数字+)"にマッチするが、欲しい文字列は数字の部分のみ
const pattern = /ECMAScript (\d+)/;
// 返り値は0番目がマッチした全体、1番目がキャプチャの1番目というように対応している
// [マッチした全部の文字列, キャプチャの1番目, キャプチャの2番目 ....]
const [all, capture1] = "ECMAScript 6".match(pattern);
console.log(all); // => "ECMAScript 6"
console.log(capture1); // => "6"
```

- `matchAll`メソッド
```Js
// "ES(数字+)"にマッチするが、欲しい文字列は数字の部分のみ
const pattern = /ES(\d+)/g;
// iteratorを返す
const matchesIterator = "ES2015、ES2016、ES2017".matchAll(pattern);
for (const match of matchesIterator) {
    // マッチした要素ごとの情報を含んでいる
    // 0番目はマッチした文字列全体、1番目がキャプチャの1番目である数字
    console.log(`match: "${match[0]}", capture1: ${match[1]}, index: ${match.index}, input: "${match.input}"`);
}
// 次の順番でコンソールに出力される
// match: "ES2015", capture1: 2015, index: 0, input: "ES2015、ES2016、ES2017"
// match: "ES2016", capture1: 2016, index: 7, input: "ES2015、ES2016、ES2017"
// match: "ES2017", capture1: 2017, index: 14, input: "ES2015、ES2016、ES2017"
```

### 疑問点（11/24）
- MacBookでバックスラッシュを出そうとすると¥マークが出てしまうので、正規表現で不利なのでは？

<!-- 2025-11-25 -->
#### [コラム]RegExp.prototype.execでのString.prototype.matchAll
- gフラグなしのパターンで検索した場合、マッチした最初の結果のみを返す
　このときexecメソッドの返り値である配列が`index`プロパティと`inpupt`プロパティが追加された特殊な配列になるのはStringの`match`メソッドと同じ
- 以下はmatchAllと同じ処理をするためにwhile文で回している
```Js
const str = "ABC あいう DE えお";
const alphabetsPattern = /[a-zA-Z]+/g;
let matches;
while (matches = alphabetsPattern.exec(str)) {
    // RegExpの`exec`メソッドの返り値は`index`プロパティなどを含む特殊な配列
    console.log(`match: ${matches[0]}, index: ${matches.index}, lastIndex: ${alphabetsPattern.lastIndex}`);
}
// 次の順番でコンソールに出力される
// match: ABC, index: 0, lastIndex: 3
// match: DE, index: 8, lastIndex: 10
```

#### 真偽値の取得
- Stringの`startsWith`相当：`/^パターン/.test(文字列)`
  - `^`は先頭に一致する特殊文字
- Stringの`endsWith`相当：`/パターン$/.test(文字列)`
  - `$`は末尾に一致する特殊文字
- Stringの`includes`相当：`/パターン/.test(文字列)`

### 文字列と正規表現どちらを使うべきか
Stringメソッドで表現できるものはStringメソッドを使い、
柔軟性やあいまいな検索が必要な場合は、コメントでどういう意図の正規表現なのか補足したうえで使う

### 文字列の置換/削除
- 文字列の一部を置換したり削除するにはStringの`replace`メソッドを利用する
- 文字列はプリミティブ型のため文字列から一部の文字を削除するような`delete`演算子は利用できない
- replaceメソッドと`replaceAll`メソッドでは、キャプチャした文字列を利用して複雑な置換処理もできる
```JS
function toDateJa(dateString) {
    // パターンにマッチしたときのみ、コールバック関数で置換処理が行われる
    return dateString.replace(/(\d{4})-(\d{2})-(\d{2})/g, (all, year, month, day) => {
        // `all`には、マッチした文字列全体が入っているが今回は利用しない
        // `all`が次の返す値で置換されるイメージ
        return `${year}年${month}月${day}日`;
    });
}
// マッチしない文字列の場合は、そのままの文字列が返る
console.log(toDateJa("本日ハ晴天ナリ")); // => "本日ハ晴天ナリ"
// マッチした場合は置換した結果を返す
console.log(toDateJa("今日は2017-03-01です")); // => "今日は2017年03月01日です"
```

### 文字列の組み立て

#### URL文字列
URL文字列を結合する時は`+`よりも専用の関数を用意したほうが良い
```Js
// ベースURLとパスを結合した文字列を返す
function baseJoin(baseURL, pathname) {
    // 末尾に / がある場合は、/ を削除してから結合する
    const stripSlashBaseURL = baseURL.replace(/\/$/, "");
    return stripSlashBaseURL + pathname;
}
// `baseURL`と`pathname`にあるリソースを取得する
function getResource(baseURL, pathname) {
    const url = baseJoin(baseURL, pathname);
    // baseURLの末尾に / があってもなくても同じ結果となる
    console.log(url); // => "http://example.com/resources/example.js"
    // 省略) リソースを取得する処理...
}
const baseURL = "http://example.com/resources/";
const pathname = "/example.js";
getResource(baseURL, pathname);
```

### [ES2015] タグつきテンプレート関数
タグつきテンプレートで利用する関数のことを**タグ関数**と呼ぶ
```md
関数`テンプレート`という書式で呼び出す
```
※ 関数`()`ではないところに注意
```JS
// テンプレートを順番どおりに結合した文字列を返すタグ関数
function stringRaw(strings, ...values) {
    // 配列から文字列を返すためにreduceメソッドを利用する
    // resultの初期値はstrings[0]の値となる
    return strings.reduce((result, str, i) => {
        console.log([result, values[i - 1], str]);
        // それぞれループで次のような出力となる
        // 1度目: ["template ", 0, " literal "]
        // 2度目: ["template 0 literal ", 1, ""]
        return result + values[i - 1] + str;
    });
}
// 関数`テンプレートリテラル` という形で呼び出す
console.log(stringRaw`template ${0} literal ${1}`); // => "template 0 literal 1"
```

- 上記のStringRaw関数と同様のことを`String.raw`静的メソッド[ES2015]で実装できる
```JS
console.log(String.raw`template ${0} literal ${1}`); // => "template 0 literal 1"
```


### 疑問点
- プリミティブ型とはなんだったのか
- ...valuesのようなspread関数とはなんだったか
- 以下の処理が良くわからない
```Js
// 変数をURLエスケープするタグ関数
function escapeURL(strings, ...values) {
    return strings.reduce((result, str, i) => {
        return result + encodeURIComponent(values[i - 1]) + str;
    });
}

const input = "A&B";
// escapeURLタグ関数を使ったタグつきテンプレート
const escapedURL = escapeURL`https://example.com/search?q=${input}&sort=desc`;
console.log(escapedURL); // => "https://example.com/search?q=A%26B&sort=desc"
```

## 16 文字列とUnicode（ToDo）

## 17 ラッパーオブジェクト

## 18 関数とスコープ

## 19 関数とthis

## 20 クラス

## 21 例外処理

## 22 非同期処理:Promise/Async Function

## 23 Map/Set

## 24 イテレータとジェネレータ

<!-- 2025-11-29 -->
## 25 JSON
JavaScript Object Notationの略で、JavaScriptのオブジェクトをベースに作られた軽量なデータフォーマット

### `JSON`オブジェクト
JSON形式の文字列とJavaScriptのオブジェクトを相互に変換するための`parse`メソッドと`stringify`メソッドを提供する
```Js
// JSONはダブルクォートのみを許容するため、シングルクォートでJSON文字列を記述
const json = '{ "id": 1, "name": "js-primer" }';
const obj = JSON.parse(json);
console.log(obj.id); // => 1
console.log(obj.name); // => "js-primer"
```

### オブジェクトをJSON文字列に変換する
- 使う場面
  - HTTP通信でサーバーにデータを送信する時
  - アプリケーションが保持している状態を外部に保存する時など

- `JSON.stringify`静的メソッド
  - 第一引数に与えられたオブジェクトをJSON形式にする
```Js
const obj = { id: 1, name: "js-primer", bio: null };
console.log(JSON.stringify(obj)); // => '{"id":1,"name":"js-primer","bio":null}'
```
  - 第二引数（replacer引数）に関数または配列を渡すことで、文字列に変換される挙動をコントロールできる
```Js
const obj = { id: 1, name: "js-primer", bio: null };
const replacer = (key, value) => {
    if (value === null) {
        return undefined;
    }
    return value;
};
console.log(JSON.stringify(obj, replacer)); // => '{"id":1,"name":"js-primer"}'
```
  - 第三引数（space引数）を渡すことで、変換後のJSON形式の文字列を読みやすくフォーマットする際のインデントを設定できる
```Js
const obj = { id: 1, name: "js-primer" };
// replacer引数を使わない場合はnullを渡して省略するのが一般的です
console.log(JSON.stringify(obj, null, 2));
/*
{
   "id": 1, 
   "name": "js-primer"
}
*/
```

### JSONにシリアライズできないオブジェクト
`JSON.stringify`静的メソッドはJSONで実現可能な値だけシリアライズする

### `toJSON`メソッドを使ったシリアライズ
オブジェクトが`toJSON`メソッドを持っている場合、`toJSON`メソッドの返り値を使う
```Js
const obj = {
    foo: "foo",
    toJSON() {
        return "bar";
    }
};
console.log(JSON.stringify(obj)); // => '"bar"'
console.log(JSON.stringify({ x: obj })); // => '{"x":"bar"}'
```






## 26 Date

## 27 Math

<!-- 2025-11-29 -->
## 28 ECMAScriptモジュール
**モジュール：**変数や関数をまとめたもの
- JavaScriptにおいては、１つのモジュールは１つのJavaScriptファイルに対応する
- モジュールは、保守性・名前空間・再利用性のために使われる
  - 保守性：依存性の高いコードの酒豪を一か所にまとめることで他のモジュールへの依存性を減らす
  - 名前空間：モジュールごとにスコープを分けることで、グローバルな名前空間を汚染しない
  - 再利用性：便利な変数や関数を複数の場所にコピペせず、モジュールとして再利用できる

### ECMAScriptモジュールの構文

#### 名前付きエクスポート/インポート

##### 名前付きエクスポート
- 宣言済みのオブジェクトを名前付きエクスポート
```Js
// named-export.js
const foo = "foo";
// 宣言済みのオブジェクトを名前つきエクスポートする
export { foo };
```
- 宣言と同時に名前付きエクスポート
```Js
// named-export-declare.js
// 宣言と同時に名前つきエクスポートする
export function bar() { };
```

##### 名前付きインポート
exportして、import文の後の`{}`の中に、インポートしたい名前付きエクスポートの名前を入れる
```Js
// my-module.js
export const foo = "foo";
export function bar() { }
```
```Js
// named-import.js
// 名前つきエクスポートされたfooとbarをインポートする
import { foo, bar } from "./my-module.js";
console.log(foo); // => "foo"
console.log(bar); // => function bar()
```

##### 名前付きエクスポート/インポートのエイリアス
エイリアスを使うと宣言済みの変数を違う名前で名前付きエクスポート/インポートできる
- 名前付きエクスポート
```Js
// named-export-alias.js
const internalFoo = "foo";
// internalFoo変数をfooとして名前つきエクスポートする
export { internalFoo as foo };
```
- 名前付きインポート
```Js
// named-import-alias.js
// fooとして名前つきエクスポートされた変数をmyFooとしてインポートする
import { foo as myFoo } from "./named-export-alias.js";
console.log(myFoo); // => "foo"
```

#### デフォルトエクスポート/インポート
デフォルトエクスポートは、モジュールごとに１つしかエクスポートできない

##### デフォルトエクスポート
- `export default`文で、後に続く式の評価結果をデフォルトエクスポートする
```Js
// default-export.js
const foo = "foo";
// foo変数の値をデフォルトエクスポートする
export default foo;
```
- 宣言と同時に関数をデフォルトエクスポート
```Js
// 宣言と同時に関数をデフォルトエクスポートする
export default function() {}
```
- 変数宣言とデフォルトエクスポートは同時にできない
```Js
// 変数宣言と同時にデフォルトエクスポートはできない
export default const foo = "foo", bar = "bar";
```

##### デフォルトインポート
- `import`文で、指定したモジュールのデフォルトエクスポートに名前を付けてインポートする
```Js
// my-module.js
export default {
    baz: "baz"
};
```
```Js
// default-import.js
// デフォルトエクスポートをmyModuleとしてインポートする
import myModule from "./my-module.js";
console.log(myModule); // => { baz: "baz" }
```

##### エイリアスで名前付きをデフォルトへ
- 名前付きエクスポートを`as default`とエイリアスを付けることでデフォルトエクスポート/インポートできる
```Js
// default-export-alias.js
const foo = "foo";
// foo変数の値をデフォルトエクスポートする
export { foo as default };
```

##### 名前付きインポートとデフォルトインポートを同時に記述
カンマで構文を繋げられる
```Js
// myModuleとしてデフォルトインポートし、
// fooを名前つきインポートする
import myModule, { foo } from "./my-module.js";
console.log(foo); // => "foo"
console.log(myModule); // => { baz: "baz" }
```

#### 再エクスポート
別のモジュールからインポートしたものを、改めて自分自身からエクスポートしなおすこと
- `export`文のあとに`from`を続けて、別のモジュールとして指定する

#### すべてをインポート
- `import * as`構文は、すべての名前付きエクスポートをまとめてインポートする

#### 副作用のためのインポート
モジュールの中には、グローバルのコードを実行するだけで何もエクスポートしないものがある

#### [ES2020]Dynamic Import
動的にモジュールをインポートで機能
- ユーザーがボタンをクリックしたときにモジュールを読み込んだり、大きなライブライを必要になったタイミングで読み込むことができる
- `import`演算子を使う
  - Promiseを返すため、`.then`メソッドや`async/await`構文と組み合わせて使う
```Js
// math-utils.js
export const add = (a, b) => a + b;
```
```Js
// 条件分岐でモジュールを動的にインポート
const condition = true;

if (condition) {
    import("./math-utils.js")
        .then((module) => {
            // インポートしたモジュールを使用
            console.log(module.add(1, 2));
        });
}
```

#### [ES2025] インポート属性
モジュールをインポートするときに追加の属性情報を指定できる

- 次のコードは読み込むファイルがJSONデータであることを明示している
```Js
// data.json
{
  "name": "John",
  "age": 30
}
```
```Js
// main.js
import jsonData from "./data.json" with { type: "json" };
console.log(jsonData.name); // => "John"
console.log(jsonData.age); // => 30
```


## 29 ECMAScript